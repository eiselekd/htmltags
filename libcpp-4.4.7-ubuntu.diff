diff -Naur gcc-src.ori/libcpp/directives.c gcc-src/libcpp/directives.c
--- gcc-src.ori/libcpp/directives.c	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/directives.c	2015-02-01 16:17:29.756764932 +0100
@@ -27,17 +27,7 @@
 #include "mkdeps.h"
 #include "obstack.h"
 
-/* Stack of conditionals currently in progress
-   (including both successful and failing conditionals).  */
-struct if_stack
-{
-  struct if_stack *next;
-  linenum_type line;		/* Line where condition started.  */
-  const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */
-  bool skip_elses;		/* Can future #else / #elif be skipped?  */
-  bool was_skipping;		/* If were skipping on entry.  */
-  int type;			/* Most recent conditional for diagnostics.  */
-};
+extern int macroid;
 
 /* Contains a registered pragma or pragma namespace.  */
 typedef void (*pragma_cb) (cpp_reader *);
@@ -90,7 +80,7 @@
 };
 
 /* Forward declarations.  */
-
+struct cpp_macro *push_depend (cpp_reader *pfile, const char *n);
 static void skip_rest_of_line (cpp_reader *);
 static void check_eol (cpp_reader *);
 static void start_directive (cpp_reader *);
@@ -100,11 +90,11 @@
 static void run_directive (cpp_reader *, int, const char *, size_t);
 static char *glue_header_name (cpp_reader *);
 static const char *parse_include (cpp_reader *, int *, const cpp_token ***);
-static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *);
+static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *, struct cpp_macro *);
 static unsigned int read_flag (cpp_reader *, unsigned int);
 static bool strtolinenum (const uchar *, size_t, linenum_type *, bool *);
 static void do_diagnostic (cpp_reader *, int, int);
-static cpp_hashnode *lex_macro_node (cpp_reader *, bool);
+static cpp_hashnode *lex_macro_node (cpp_reader *, bool, cpp_token **);
 static int undefine_macros (cpp_reader *, cpp_hashnode *, void *);
 static void do_include_common (cpp_reader *, enum include_type);
 static struct pragma_entry *lookup_pragma_entry (struct pragma_entry *,
@@ -208,6 +198,10 @@
   if (! SEEN_EOL ())
     while (_cpp_lex_token (pfile)->type != CPP_EOF)
       ;
+
+  /* a #include a with a expandsion to "file.h" will have context open */
+  pfile->cb.parse_info_cb.pathcnt = 0;
+
 }
 
 /* Ensure there are no stray tokens at the end of a directive.  */
@@ -266,6 +260,8 @@
   /* Setup in-directive state.  */
   pfile->state.in_directive = 1;
   pfile->state.save_comments = 0;
+  pfile->state.save_spaces = 0;
+  pfile->state.skipping_old = pfile->state.skipping;
   pfile->directive_result.type = CPP_PADDING;
 
   /* Some handlers need the position of the # for diagnostics.  */
@@ -298,9 +294,19 @@
 	}
     }
 
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+      pfile->state.skipping_old != pfile->state.skipping) {
+      pfile->cb.parse_info_cb.gen_parse_info_loc_line(pfile->directive_line);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("->");
+      pfile->cb.parse_info_cb.gen_parse_info_loc_line(pfile->line_table->highest_line);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#:%d->%d\n",pfile->state.skipping_old,pfile->state.skipping);
+  }
+
   /* Restore state.  */
   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);
+  pfile->state.save_spaces = CPP_OPTION (pfile, preserve_spaces);
   pfile->state.in_directive = 0;
+  pfile->state.dep = 0;
   pfile->state.in_expression = 0;
   pfile->state.angled_headers = 0;
   pfile->directive = 0;
@@ -525,9 +531,10 @@
    processing a #define or #undefine directive, and false
    otherwise.  */
 static cpp_hashnode *
-lex_macro_node (cpp_reader *pfile, bool is_def_or_undef)
+lex_macro_node (cpp_reader *pfile, bool is_def_or_undef, cpp_token **rtoken)
 {
   const cpp_token *token = _cpp_lex_token (pfile);
+  *rtoken = (cpp_token *)token;
 
   /* The token immediately after #define must be an identifier.  That
      identifier may not be "defined", per C99 6.10.8p4.
@@ -563,7 +570,9 @@
 static void
 do_define (cpp_reader *pfile)
 {
-  cpp_hashnode *node = lex_macro_node (pfile, true);
+  cpp_token *tok;
+  cpp_hashnode *node = lex_macro_node (pfile, true, &tok);
+  cpp_macro *macro;
 
   if (node)
     {
@@ -571,14 +580,31 @@
 	 then re-enable saving of comments.  */
       pfile->state.save_comments =
 	! CPP_OPTION (pfile, discard_comments_in_macro_exp);
+      pfile->state.save_spaces =
+          CPP_OPTION (pfile, preserve_spaces);
 
       if (pfile->cb.before_define)
 	pfile->cb.before_define (pfile);
 
-      if (_cpp_create_definition (pfile, node))
+      if (_cpp_create_definition (pfile, node)) {
 	if (pfile->cb.define)
 	  pfile->cb.define (pfile, pfile->directive_line, node);
 
+        macro = node->value.macro;
+	if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+            char *mdef;  
+            mdef = (char *)cpp_macro_definition (pfile, node); 
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("#define(@%d) \t",macro->macroid);
+	    pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+	    pfile->cb.parse_info_cb.gen_parse_info_printf(":[");
+	    pfile->cb.parse_info_cb.gen_parse_info_loc(pfile->directive_line);
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("]-[");
+	    pfile->cb.parse_info_cb.gen_parse_info_loc(pfile->line_table->highest_line);
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("]:%s\n",mdef);
+	}
+	
+      }
+
       node->flags &= ~NODE_USED;
     }
 }
@@ -587,7 +613,8 @@
 static void
 do_undef (cpp_reader *pfile)
 {
-  cpp_hashnode *node = lex_macro_node (pfile, true);
+  cpp_token *tok;
+  cpp_hashnode *node = lex_macro_node (pfile, true, &tok);
 
   if (node)
     {
@@ -773,6 +800,7 @@
       /* Get out of macro context, if we are.  */
       skip_rest_of_line (pfile);
 
+	    
       if (pfile->cb.include)
 	pfile->cb.include (pfile, pfile->directive_line,
 			   pfile->directive->name, fname, angle_brackets,
@@ -1761,20 +1789,29 @@
   return 0;
 }
 
+void directory_dep_push(cpp_reader *pfile, cpp_macro *m) {
+	if (pfile->state.in_directive && 
+	    pfile->state.dep ) {
+		_cpp_macro_dep_push (pfile, pfile->state.dep, m);
+	}
+}
+
 /* Handle #ifdef.  */
 static void
 do_ifdef (cpp_reader *pfile)
 {
   int skip = 1;
+  cpp_token *tok;
+  struct cpp_macro *dep = push_depend (pfile,"<ifdef>");
 
   if (! pfile->state.skipping)
     {
-      cpp_hashnode *node = lex_macro_node (pfile, false);
+      cpp_hashnode *node = lex_macro_node (pfile, false, &tok);
 
       if (node)
 	{
 	  skip = node->type != NT_MACRO;
-	  _cpp_mark_macro_used (node);
+	  _cpp_mark_macro_used (pfile,node);
 	  if (!(node->flags & NODE_USED))
 	    {
 	      node->flags |= NODE_USED;
@@ -1791,9 +1828,39 @@
 	    }
 	  check_eol (pfile);
 	}
+
+         
+      if (tok && pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          int oreplaceid = replaceid++;
+          cpp_token num;
+          
+          parse_info_directive_token(pfile, (cpp_token *)tok);
+          
+          /*	<=381   (2.3)   #NAME          [defined]:test.c@4:@#define(a)  */
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",tok->tokid);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[");
+          pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (tok->val.node), (int)NODE_LEN (tok->val.node));
+          pfile->cb.parse_info_cb.gen_parse_info_printf("](@0)#");
+          pfile->cb.parse_info_cb.gen_parse_info_loc(tok->src_loc);
+          pfile->cb.parse_info_cb.gen_parse_info_printf("#defined(");
+          pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (tok->val.node), (int)NODE_LEN (tok->val.node));
+          pfile->cb.parse_info_cb.gen_parse_info_printf(")\n");
+          
+          /*     407     [1]     .c1:   NAME        [g */
+          num.type = CPP_NUMBER;
+          num.flags = 0;
+          num.val.str.len = 1;
+          num.val.str.text = skip ? (const unsigned char *)"0" : (const unsigned char *)"1";
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",tok->tokid);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+          pfile->cb.parse_info_cb.gen_parse_info_char("\tp:\t");
+          pfile->cb.parse_info_cb.gen_parse_info_token(&num);
+          pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+      }
     }
 
-  push_conditional (pfile, skip, T_IFDEF, 0);
+  push_conditional (pfile, skip, T_IFDEF, 0, dep);
 }
 
 /* Handle #ifndef.  */
@@ -1802,15 +1869,17 @@
 {
   int skip = 1;
   cpp_hashnode *node = 0;
+  cpp_token *tok;
+  struct cpp_macro *dep = push_depend (pfile,"<ifndef>");
 
   if (! pfile->state.skipping)
     {
-      node = lex_macro_node (pfile, false);
+      node = lex_macro_node (pfile, false, &tok);
 
       if (node)
 	{
 	  skip = node->type == NT_MACRO;
-	  _cpp_mark_macro_used (node);
+	  _cpp_mark_macro_used (pfile,node);
 	  if (!(node->flags & NODE_USED))
 	    {
 	      node->flags |= NODE_USED;
@@ -1829,7 +1898,7 @@
 	}
     }
 
-  push_conditional (pfile, skip, T_IFNDEF, node);
+  push_conditional (pfile, skip, T_IFNDEF, node, dep);
 }
 
 /* _cpp_parse_expr puts a macro in a "#if !defined ()" expression in
@@ -1841,11 +1910,12 @@
 do_if (cpp_reader *pfile)
 {
   int skip = 1;
+  struct cpp_macro *dep = push_depend (pfile,"<if>");
 
   if (! pfile->state.skipping)
     skip = _cpp_parse_expr (pfile, true) == false;
 
-  push_conditional (pfile, skip, T_IF, pfile->mi_ind_cmacro);
+  push_conditional (pfile, skip, T_IF, pfile->mi_ind_cmacro, dep);
 }
 
 /* Flip skipping state if appropriate and continue without changing
@@ -1954,13 +2024,28 @@
     }
 }
 
+struct cpp_macro *push_depend (cpp_reader *pfile, const char *n) {
+	struct cpp_macro *depend = 0;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info) {
+		depend =   (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));
+		memset(depend, 0, sizeof(cpp_macro));
+		depend->line = pfile->directive_line;
+		depend->macroid = macroid++;
+		depend->name = xstrdup(n);
+		add_cpp_all_macros(depend);
+		
+		pfile->state.dep = depend;
+	}
+	return depend;
+}
+
 /* Push an if_stack entry for a preprocessor conditional, and set
    pfile->state.skipping to SKIP.  If TYPE indicates the conditional
    is #if or #ifndef, CMACRO is a potentially controlling macro, and
    we need to check here that we are at the top of the file.  */
 static void
 push_conditional (cpp_reader *pfile, int skip, int type,
-		  const cpp_hashnode *cmacro)
+		  const cpp_hashnode *cmacro, struct cpp_macro *dep)
 {
   struct if_stack *ifs;
   cpp_buffer *buffer = pfile->buffer;
@@ -1971,6 +2056,17 @@
   ifs->skip_elses = pfile->state.skipping || !skip;
   ifs->was_skipping = pfile->state.skipping;
   ifs->type = type;
+  ifs->depend = dep;
+  
+  if (pfile->cb.parse_info_cb.flag_gen_dep_info) {
+	  if (dep &&
+	      ifs->next &&
+	      ifs->next->depend) {
+		  _cpp_macro_dep_push (pfile, dep, ifs->next->depend);
+	  }
+	  
+  }
+  
   /* This condition is effectively a test for top-of-file.  */
   if (pfile->mi_valid && pfile->mi_cmacro == 0)
     ifs->mi_cmacro = cmacro;
@@ -2288,6 +2384,9 @@
 void
 cpp_undef (cpp_reader *pfile, const char *macro)
 {
+	/* todo: for dep-info, record all macros with same name (undef and subsequently redefined)
+	   and add dependencies of _all_ instead only the last one */
+
   size_t len = strlen (macro);
   char *buf = (char *) alloca (len + 1);
   memcpy (buf, macro, len);
diff -Naur gcc-src.ori/libcpp/expr.c gcc-src/libcpp/expr.c
--- gcc-src.ori/libcpp/expr.c	2009-04-10 01:23:07.000000000 +0200
+++ gcc-src/libcpp/expr.c	2015-02-01 12:43:12.992556994 +0100
@@ -35,6 +35,8 @@
   enum cpp_ttype op;
 };
 
+extern int replaceid; /* macro.c */
+
 /* Some simple utility routines on double integers.  */
 #define num_zerop(num) ((num.low | num.high) == 0)
 #define num_eq(num1, num2) (num1.low == num2.low && num1.high == num2.high)
@@ -57,7 +59,7 @@
 static cpp_num num_rshift (cpp_num, size_t, size_t);
 
 static cpp_num append_digit (cpp_num, int, int, size_t);
-static cpp_num parse_defined (cpp_reader *);
+static cpp_num parse_defined (cpp_reader *, int );
 static cpp_num eval_token (cpp_reader *, const cpp_token *);
 static struct op *reduce (cpp_reader *, struct op *, enum cpp_ttype);
 static unsigned int interpret_float_suffix (const uchar *, size_t);
@@ -76,6 +78,23 @@
   do { cpp_error (pfile, CPP_DL_ERROR, msgid, arg); goto syntax_error; } \
   while(0)
 
+void 
+parse_info_directive_token (cpp_reader *pfile, cpp_token *token) {
+    if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+        pfile->cb.parse_info_cb.gen_parse_info_updateloc(&pfile->cb.parse_info_cb, token->src_loc,0);
+
+#ifdef USE_MAPPED_LOCATION
+	fprintf(stderr,"--enable-mapped-location for -fparse-info not implemeneted yet\n");
+	abort();
+#else 
+	pfile->cb.parse_info_cb.gen_parse_info_header(token->tokid,token->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+#endif
+	pfile->cb.parse_info_cb.gen_parse_info_printf("#:",token->tokid);
+        pfile->cb.parse_info_cb.gen_parse_info_token (token);
+        pfile->cb.parse_info_cb.gen_parse_info_char ("\n");
+    }
+}
+
 /* Subroutine of cpp_classify_number.  S points to a float suffix of
    length LEN, possibly zero.  Returns 0 for an invalid suffix, or a
    flag vector describing the suffix.  */
@@ -586,32 +605,46 @@
 
 /* Handle meeting "defined" in a preprocessor expression.  */
 static cpp_num
-parse_defined (cpp_reader *pfile)
+parse_defined (cpp_reader *pfile, int tokid)
 {
   cpp_num result;
   int paren = 0;
   cpp_hashnode *node = 0;
-  const cpp_token *token;
+  const cpp_token *token, *name_token = 0;
   cpp_context *initial_context = pfile->context;
 
   /* Don't expand macros.  */
   pfile->state.prevent_expansion++;
 
   token = cpp_get_token (pfile);
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      parse_info_directive_token(pfile, (cpp_token *)token);
+  }
+
   if (token->type == CPP_OPEN_PAREN)
     {
       paren = 1;
       token = cpp_get_token (pfile);
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          parse_info_directive_token(pfile, (cpp_token *)token);
+      }
     }
 
   if (token->type == CPP_NAME)
     {
+      const cpp_token *l = 0;
+      name_token = token;
       node = token->val.node;
-      if (paren && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)
+      if (paren) {
+          if ((!(l = cpp_get_token (pfile))) || (l->type  != CPP_CLOSE_PAREN))
 	{
 	  cpp_error (pfile, CPP_DL_ERROR, "missing ')' after \"defined\"");
 	  node = 0;
 	}
+          if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+              parse_info_directive_token(pfile, (cpp_token *)l);
+          }
+      }
     }
   else
     {
@@ -636,7 +669,7 @@
 	cpp_error (pfile, CPP_DL_WARNING,
 		   "this use of \"defined\" may not be portable");
 
-      _cpp_mark_macro_used (node);
+      _cpp_mark_macro_used (pfile,node);
       if (!(node->flags & NODE_USED))
 	{
 	  node->flags |= NODE_USED;
@@ -663,6 +696,66 @@
   result.high = 0;
   result.overflow = false;
   result.low = node && node->type == NT_MACRO;
+
+  if (name_token && pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      int oreplaceid = replaceid++;
+      cpp_macro *macro = node->value.macro;
+      cpp_token num;
+      /*	<=381   (2.3)   #NAME          [defined]:test.c@4:@#define(a)  */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",tokid);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[defined](@0)#",0);
+      pfile->cb.parse_info_cb.gen_parse_info_loc(name_token->src_loc);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("#defined(");
+      pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+      pfile->cb.parse_info_cb.gen_parse_info_printf(")\n");
+      
+      /*        408     (2.3)   #GRP     [( */
+      if (paren) {
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0 /*pfile->opentokid */);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[(\n");
+      }
+      
+      /*     407     (1)     .c1:   NAME        [g */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",name_token->tokid);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_char("\tp:\t");
+      pfile->cb.parse_info_cb.gen_parse_info_token(name_token);
+      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+      
+      /*        408     (2.3)   #GRP     [) */
+      if (paren) {
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0 /*pfile->opentokid */);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[)\n");
+      }
+      if (result.low) {
+	  /* macro exists */
+	  int oreplaceid = replaceid++;
+	  char *mdef = (char *)cpp_macro_definition (pfile, node); 
+	  
+	  /*	<=381   (2.3)   #NAME          [defined]:test.c@4:@#define(a)  */
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",name_token->tokid);
+	  pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[",0);
+	  pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("](@%d)#",macro ? macro->macroid : 0);
+	  pfile->cb.parse_info_cb.gen_parse_info_loc(macro->line);
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("#%s\n",mdef);
+      
+      }
+      /*     407     [1]     .c1:   NAME        [g */
+      num.type = CPP_NUMBER;
+      num.flags = 0;
+      num.val.str.len = 1;
+      num.val.str.text = result.low ? (const unsigned char *)"1" : (const unsigned char *)"0";
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0/*name_token->tokid*/);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+      pfile->cb.parse_info_cb.gen_parse_info_char("\tp:\t");
+      pfile->cb.parse_info_cb.gen_parse_info_token(&num);
+      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+  }
   return result;
 }
 
@@ -727,7 +820,7 @@
 
     case CPP_NAME:
       if (token->val.node == pfile->spec_nodes.n_defined)
-	return parse_defined (pfile);
+          return parse_defined (pfile,token->tokid);
       else if (CPP_OPTION (pfile, cplusplus)
 	       && (token->val.node == pfile->spec_nodes.n_true
 		   || token->val.node == pfile->spec_nodes.n_false))
@@ -876,6 +969,14 @@
       op.token = cpp_get_token (pfile);
       op.op = op.token->type;
       op.loc = op.token->src_loc;
+      
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          if (op.token->type == CPP_NAME && 
+              op.token->val.node == pfile->spec_nodes.n_defined) {
+              ((cpp_token *)op.token)->tokid = tokid++;
+          }
+          parse_info_directive_token(pfile, (cpp_token *)op.token);
+      }
 
       switch (op.op)
 	{
@@ -907,9 +1008,11 @@
 	  break;
 
 	default:
-	  if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ)
+            if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ) {
+                printf("error: typ:%d, comment:%d,%d%d in_dir: %d\n", op.op, op.op == CPP_COMMENT, CPP_COMMENT, CPP_OTHER, pfile->state.in_directive);
 	    SYNTAX_ERROR2 ("token \"%s\" is not valid in preprocessor expressions",
 			   cpp_token_as_text (pfile, op.token));
+            }
 	  break;
 	}
 
diff -Naur gcc-src.ori/libcpp/files.c gcc-src/libcpp/files.c
--- gcc-src.ori/libcpp/files.c	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/files.c	2015-02-01 12:45:36.796559320 +0100
@@ -792,8 +792,15 @@
   cpp_buffer *buffer;
   int sysp;
 
-  if (!should_stack_file (pfile, file, import))
+  if (!should_stack_file (pfile, file, import)) {
+      if (file->cmacro && file->cmacro->type == NT_MACRO) {
+          if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+              pfile->cb.parse_info_cb.gen_parse_info_loc_line(pfile->line_table->highest_line);
+              pfile->cb.parse_info_cb.gen_parse_info_printf("@# include +- %s\n",file->path);
+          }
+      }
       return false;
+  }
 
   if (pfile->buffer == NULL || file->dir == NULL)
     sysp = 0;
diff -Naur gcc-src.ori/libcpp/include/cpp-id-data.h gcc-src/libcpp/include/cpp-id-data.h
--- gcc-src.ori/libcpp/include/cpp-id-data.h	2009-04-10 01:23:07.000000000 +0200
+++ gcc-src/libcpp/include/cpp-id-data.h	2015-02-01 12:45:39.412559362 +0100
@@ -75,4 +75,15 @@
 
   /* Indicate which field of 'exp' is in use.  */
   unsigned int traditional : 1;
+
+  int * GTY ((length ("%h.notecnt"))) note;
+  int notecnt;
+  
+  int macroid;
+
+  struct cpp_macro ** GTY((length("%h.depend_cnt"))) depend;
+  int depend_cnt;
+  
+  char *name;
+  
 };
diff -Naur gcc-src.ori/libcpp/include/cpplib.h gcc-src/libcpp/include/cpplib.h
--- gcc-src.ori/libcpp/include/cpplib.h	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/include/cpplib.h	2015-02-01 16:25:11.184772395 +0100
@@ -139,6 +139,7 @@
   TK(MACRO_ARG,		NONE)	 /* Macro argument.  */			\
   TK(PRAGMA,		NONE)	 /* Only for deferred pragmas.  */	\
   TK(PRAGMA_EOL,	NONE)	 /* End-of-line for deferred pragmas.  */ \
+  TK(PARSEINFOSTACK,	NONE)	 /* push parseinfo token on path stack.  */ \
   TK(PADDING,		NONE)	 /* Whitespace for -E.	*/
 
 #define OP(e, s) CPP_ ## e,
@@ -179,6 +180,8 @@
 #define PURE_ZERO	(1 << 7) /* Single 0 digit, used by the C++ frontend,
 				    set in c-lex.c.  */
 
+#define CPP_MACRO_NEWLINE (1 << 8)
+
 /* Specify which field, if any, of the cpp_token union is used.  */
 
 enum cpp_token_fld_kind {
@@ -187,6 +190,7 @@
   CPP_TOKEN_FLD_STR,
   CPP_TOKEN_FLD_ARG_NO,
   CPP_TOKEN_FLD_PRAGMA,
+  CPP_TOKEN_FLD_PARSEINFOSTACK,
   CPP_TOKEN_FLD_NONE
 };
 
@@ -196,7 +200,7 @@
 {
   source_location src_loc;	/* Location of first char of token.  */
   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */
-  unsigned char flags;		/* flags - see above */
+  unsigned int flags;		/* flags - see above */
 
   union cpp_token_u
   {
@@ -217,9 +221,15 @@
     /* Argument no. for a CPP_MACRO_ARG.  */
     unsigned int GTY ((tag ("CPP_TOKEN_FLD_ARG_NO"))) arg_no;
 
+    /* stack item for a CPP_PARSEINFOSTACK.  */
+    unsigned int GTY ((tag ("CPP_TOKEN_FLD_PARSEINFOSTACK"))) parseinfostack;
+
     /* Caller-supplied identifier for a CPP_PRAGMA.  */
     unsigned int GTY ((tag ("CPP_TOKEN_FLD_PRAGMA"))) pragma;
   } GTY ((desc ("cpp_token_val_index (&%1)"))) val;
+
+  int tokid;
+  struct cpp_macro *macro;
 };
 
 /* Say which field is in use.  */
@@ -287,6 +297,9 @@
      macro expansion.  */
   unsigned char discard_comments_in_macro_exp;
 
+  /* Nonzero means to retain spaces in preprocessing output.  */
+  unsigned char preserve_spaces;
+
   /* Nonzero means process the ISO trigraph sequences.  */
   unsigned char trigraphs;
 
@@ -373,6 +386,9 @@
      bother trying to do macro expansion and whatnot.  */
   unsigned char preprocessed;
 
+  /* Nonzero means we're inclding newlines of macro definition.  */
+  unsigned char fpreprocessnewline;
+    
   /* Print column number in error messages.  */
   unsigned char show_column;
 
@@ -451,8 +467,34 @@
 typedef const char *(*missing_header_cb)(cpp_reader *, const char *header, cpp_dir **);
 
 /* Call backs to cpplib client.  */
+struct cpp_parse_info_callbacks
+{
+    void (*gen_dep_info_macro) (const struct cpp_macro *);
+
+    void (*gen_parse_info_token) (const cpp_token *);
+    void (*gen_parse_info_header) (int, source_location,int *, int);
+    void (*gen_parse_info_header_direct) (int, source_location, int *, int, int);
+    void (*gen_parse_info_path_direct) (int *, int, int, int, int);
+    void (*gen_parse_info_char)(const char*);
+    void (*gen_parse_info_write)(const char*, int );
+    void (*gen_parse_info_loc)(source_location);
+    void (*gen_parse_info_loc_line)(source_location);
+    void (*gen_parse_info_printf)(const char *fmt, ...);
+    void (*gen_parse_info_updateloc)(struct cpp_parse_info_callbacks *cb, source_location src_loc, int);
+	
+
+    int flag_gen_dep_info;
+    int flag_gen_parse_info;
+    int *path;
+    int pathcnt;
+    int src_line;
+};
+
+/* Call backs to cpplib client.  */
 struct cpp_callbacks
 {
+    struct cpp_parse_info_callbacks parse_info_cb;
+
   /* Called when a new line of preprocessed output is started.  */
   void (*line_change) (cpp_reader *, const cpp_token *, int);
 
@@ -694,6 +736,7 @@
 extern unsigned char *cpp_token_as_text (cpp_reader *, const cpp_token *);
 extern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,
 				       unsigned char *, bool);
+extern char *cpp_output_token_buffer (const cpp_token *token);
 extern void cpp_register_pragma (cpp_reader *, const char *, const char *,
 				 void (*) (cpp_reader *), bool);
 extern void cpp_register_deferred_pragma (cpp_reader *, const char *,
diff -Naur gcc-src.ori/libcpp/include/line-map.h gcc-src/libcpp/include/line-map.h
--- gcc-src.ori/libcpp/include/line-map.h	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/include/line-map.h	2015-02-01 12:47:14.080560893 +0100
@@ -68,6 +68,7 @@
   unsigned char sysp;
   /* Number of the low-order source_location bits used for a column number.  */
   unsigned int column_bits : 8;
+  int mapid;
 };
 
 /* A set of chronological line_map structures.  */
diff -Naur gcc-src.ori/libcpp/init.c gcc-src/libcpp/init.c
--- gcc-src.ori/libcpp/init.c	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/init.c	2015-02-01 12:47:23.192561040 +0100
@@ -154,6 +154,7 @@
   CPP_OPTION (pfile, warn_multichar) = 1;
   CPP_OPTION (pfile, discard_comments) = 1;
   CPP_OPTION (pfile, discard_comments_in_macro_exp) = 1;
+  CPP_OPTION (pfile, preserve_spaces) = 0;
   CPP_OPTION (pfile, show_column) = 1;
   CPP_OPTION (pfile, tabstop) = 8;
   CPP_OPTION (pfile, operator_names) = 1;
@@ -195,6 +196,7 @@
 
   /* Initialize lexer state.  */
   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);
+  pfile->state.save_spaces = CPP_OPTION (pfile, preserve_spaces);
 
   /* Set up static tokens.  */
   pfile->avoid_paste.type = CPP_PADDING;
diff -Naur gcc-src.ori/libcpp/internal.h gcc-src/libcpp/internal.h
--- gcc-src.ori/libcpp/internal.h	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/internal.h	2015-02-01 16:20:35.212767931 +0100
@@ -37,6 +37,9 @@
 typedef int iconv_t;  /* dummy */
 #endif
 
+extern int tokid;
+extern int replaceid;
+
 struct directive;		/* Deliberately incomplete.  */
 struct pending_option;
 struct op;
@@ -91,9 +94,11 @@
 #define CPP_ALIGN2(size, align) (((size) + ((align) - 1)) & ~((align) - 1))
 #define CPP_ALIGN(size) CPP_ALIGN2 (size, DEFAULT_ALIGNMENT)
 
-#define _cpp_mark_macro_used(NODE) do {					\
-  if ((NODE)->type == NT_MACRO && !((NODE)->flags & NODE_BUILTIN))	\
-    (NODE)->value.macro->used = 1; } while (0)
+#define _cpp_mark_macro_used(pfile,NODE) do {				\
+		if ((NODE)->type == NT_MACRO && !((NODE)->flags & NODE_BUILTIN)) { \
+			(NODE)->value.macro->used = 1;			\
+			directory_dep_push(pfile, (NODE)->value.macro); } \
+	} while (0)
 
 /* A generic memory buffer, and operations on it.  */
 typedef struct _cpp_buff _cpp_buff;
@@ -103,6 +108,8 @@
   unsigned char *base, *cur, *limit;
 };
 
+extern void directory_dep_push(cpp_reader *pfile, cpp_macro *m);
+extern void add_cpp_all_macros(cpp_macro *macro);
 extern _cpp_buff *_cpp_get_buff (cpp_reader *, size_t);
 extern void _cpp_release_buff (cpp_reader *, _cpp_buff *);
 extern void _cpp_extend_buff (cpp_reader *, _cpp_buff **, size_t);
@@ -176,6 +183,8 @@
 
 struct lexer_state
 {
+	struct cpp_macro *dep;
+	
   /* Nonzero if first token on line is CPP_HASH.  */
   unsigned char in_directive;
 
@@ -186,6 +195,7 @@
 
   /* True if we are skipping a failed conditional group.  */
   unsigned char skipping;
+  unsigned char skipping_old;
 
   /* Nonzero if in a directive that takes angle-bracketed headers.  */
   unsigned char angled_headers;
@@ -197,6 +207,9 @@
      all directives apart from #define.  */
   unsigned char save_comments;
 
+  /* Nonzero to save spaces.  */
+  unsigned char save_spaces;
+
   /* Nonzero if lexing __VA_ARGS__ is valid.  */
   unsigned char va_args_ok;
 
@@ -209,6 +222,9 @@
   /* Nonzero when parsing arguments to a function-like macro.  */
   unsigned char parsing_args;
 
+  /* depth of the replacement stack, recursive through expand_args().  */
+  unsigned char replace_args;
+
   /* Nonzero if prevent_expansion is true only because output is
      being discarded.  */
   unsigned char discarding_output;
@@ -244,6 +260,19 @@
   unsigned int type;
 };
 
+/* Stack of conditionals currently in progress
+   (including both successful and failing conditionals).  */
+struct if_stack
+{
+  struct if_stack *next;
+  unsigned int line;		/* Line where condition started.  */
+  const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */
+  bool skip_elses;		/* Can future #else / #elif be skipped?  */
+  bool was_skipping;		/* If were skipping on entry.  */
+  int type;			/* Most recent conditional for diagnostics.  */
+  struct cpp_macro *depend;
+};
+
 /* Represents the contents of a file cpplib has read in.  */
 struct cpp_buffer
 {
@@ -256,6 +285,7 @@
 
   _cpp_line_note *notes;           /* Array of notes.  */
   unsigned int cur_note;           /* Next note to process.  */
+  unsigned int cur_mnote;          /* Next note to process.  */
   unsigned int notes_used;         /* Number of notes.  */
   unsigned int notes_cap;          /* Size of allocated array.  */
 
@@ -394,6 +424,8 @@
   cpp_token *cur_token;
   tokenrun base_run, *cur_run;
   unsigned int lookaheads;
+  source_location __line__;
+  int __line__cnt;
 
   /* Nonzero prevents the lexer from re-using the token runs.  */
   unsigned int keep_tokens;
@@ -484,6 +516,19 @@
 
   /* List of saved macros by push_macro.  */
   struct def_pragma_macro *pushed_macros;
+
+
+
+    int *replacestack;
+    int replacestackcnt;
+
+    int opentokid;
+    int closetokid;
+    source_location opentoksrc_loc;
+    source_location closetoksrc_loc;
+    cpp_macro *curmacro;
+
+  
 };
 
 /* Character classes.  Based on the more primitive macros in safe-ctype.h.
@@ -532,8 +577,11 @@
 }
 
 /* In macro.c */
+static cpp_token *create_parseinfo_token (cpp_reader *pfile, cpp_macro *macro) ;
+
 extern void _cpp_free_definition (cpp_hashnode *);
 extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);
+extern void _cpp_macro_dep_push (cpp_reader *, cpp_macro *, cpp_macro *);
 extern void _cpp_pop_context (cpp_reader *);
 extern void _cpp_push_text_context (cpp_reader *, cpp_hashnode *,
 				    const unsigned char *, size_t);
@@ -573,6 +621,7 @@
 /* In expr.c */
 extern bool _cpp_parse_expr (cpp_reader *, bool);
 extern struct op *_cpp_expand_op_stack (cpp_reader *);
+extern void parse_info_directive_token (cpp_reader *pfile, cpp_token *token);
 
 /* In lex.c */
 extern void _cpp_process_line_notes (cpp_reader *, int);
@@ -585,6 +634,7 @@
 extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);
 extern void _cpp_init_tokenrun (tokenrun *, unsigned int);
 extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);
+extern void _cpp_process_mline_notes (cpp_reader *);
 
 /* In init.c.  */
 extern void _cpp_maybe_push_include_file (cpp_reader *);
diff -Naur gcc-src.ori/libcpp/lex.c gcc-src/libcpp/lex.c
--- gcc-src.ori/libcpp/lex.c	2009-11-11 21:21:14.000000000 +0100
+++ gcc-src/libcpp/lex.c	2015-02-01 12:51:43.468565250 +0100
@@ -39,6 +39,8 @@
   const unsigned char *name;
 };
 
+int tokid = 1;
+
 static const unsigned char *const digraph_spellings[] =
 { UC"%:", UC"%:%:", UC"<:", UC":>", UC"<%", UC"%>" };
 
@@ -53,7 +55,7 @@
 
 static void add_line_note (cpp_buffer *, const uchar *, unsigned int);
 static int skip_line_comment (cpp_reader *);
-static void skip_whitespace (cpp_reader *, cppchar_t);
+static void skip_whitespace (cpp_reader *, cppchar_t, cpp_token *);
 static void lex_string (cpp_reader *, cpp_token *, const uchar *);
 static void save_comment (cpp_reader *, cpp_token *, const uchar *, cppchar_t);
 static void store_comment (cpp_reader *, cpp_token *);
@@ -84,6 +86,8 @@
 static void
 add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type)
 {
+    
+    
   if (buffer->notes_used == buffer->notes_cap)
     {
       buffer->notes_cap = buffer->notes_cap * 2 + 200;
@@ -106,7 +110,7 @@
   uchar c, *d, *p;
 
   buffer = pfile->buffer;
-  buffer->cur_note = buffer->notes_used = 0;
+  buffer->cur_mnote = buffer->cur_note = buffer->notes_used = 0;
   buffer->cur = buffer->line_base = buffer->next_line;
   buffer->need_line = false;
   s = buffer->next_line - 1;
@@ -152,6 +156,9 @@
 		 the slow path.  */
 	      add_line_note (buffer, p - 1, p != d ? ' ' : '\\');
 	      d = p - 2;
+              if (pfile->state.save_spaces && !pfile->state.in_directive) {
+                  *++d = 1;
+              }
 	      buffer->next_line = p - 1;
 	      break;
 	    }
@@ -199,6 +206,9 @@
 
 	      add_line_note (buffer, p - 1, p != d ? ' ': '\\');
 	      d = p - 2;
+              if (pfile->state.save_spaces && !pfile->state.in_directive) {
+                  *++d = 1;
+              }
 	      buffer->next_line = p - 1;
 	    }
 	  else if (c == '?' && s[1] == '?' && _cpp_trigraph_map[s[2]])
@@ -260,11 +270,54 @@
   return (*p == '\n' && p < note[1].pos);
 }
 
+/* void */
+/* _cpp_process_mline_notes (cpp_reader *pfile) */
+/* { */
+/*     cpp_buffer *buffer = pfile->buffer; */
+/*     cpp_macro *macro = 0; */
+    
+/*     if (pfile->cb.parse_info_cb.flag_gen_parse_info) { */
+	
+/* 	//for (;;) */
+/* 	while( buffer->notes_used  > buffer->cur_mnote) */
+/* 	    { */
+/* 		_cpp_line_note *note = &buffer->notes[buffer->cur_mnote]; */
+		
+/* 		if (note->pos > buffer->cur) */
+/* 		    break; */
+		
+/* 		buffer->cur_mnote++; */
+		
+/* 		if (note->type == '\\' || note->type == ' ') */
+/* 		    { */
+/* 			if (pfile->curmacro && note->type == '\\') { */
+/* 			    /\* register a \\ in the macro definition *\/ */
+/* 			    int idx = 0; macro = pfile->curmacro; */
+/* 			    if ((idx = macro->notecnt++)) { */
+/* 				macro->note = XRESIZEVEC(int,macro->note,macro->notecnt); */
+/* 			    } else { */
+/* 				macro->note = XNEWVEC(int,macro->notecnt); */
+/* 			    } */
+/* 			    macro->note[idx] = macro->count > 0 ? macro->count-1 : macro->count; */
+/* 			} */
+			
+/* 		    } */
+/* 		else if (_cpp_trigraph_map[note->type]) */
+/* 		    { */
+/* 		    } */
+/* 		else  */
+/* 		    break; */
+/* 	    } */
+/*     } */
+    
+/* } */
+
 /* Process the notes created by add_line_note as far as the current
    location.  */
 void
 _cpp_process_line_notes (cpp_reader *pfile, int in_comment)
 {
+    cpp_macro *macro = 0;
   cpp_buffer *buffer = pfile->buffer;
 
   for (;;)
@@ -280,6 +333,27 @@
 
       if (note->type == '\\' || note->type == ' ')
 	{
+	    if (pfile->cb.parse_info_cb.flag_gen_parse_info ||
+                CPP_OPTION (pfile, fpreprocessnewline)) {
+		if (pfile->curmacro && note->type == '\\') {
+		    /* register a \\ in the macro definition */
+		    int idx = 0; macro = pfile->curmacro;
+		    if ((idx = macro->notecnt++)) {
+			macro->note = XRESIZEVEC(int,macro->note,macro->notecnt);
+		    } else {
+			macro->note = XNEWVEC(int,macro->notecnt);
+		    }
+		    macro->note[idx] = macro->count > 0 ? macro->count-1 : macro->count;
+		}
+	    }
+	    
+	    
+	    /*
+	    if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+		pfile->cb.parse_info_cb.gen_parse_info_char("@(\\)\n");
+	    }
+	    */
+	    
 	  if (note->type == ' ' && !in_comment)
 	    cpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line_table->highest_line, col,
 				 "backslash and newline separated by space");
@@ -397,34 +471,58 @@
 
 /* Skips whitespace, saving the next non-whitespace character.  */
 static void
-skip_whitespace (cpp_reader *pfile, cppchar_t c)
+skip_whitespace (cpp_reader *pfile, cppchar_t c, cpp_token *token)
 {
+  cppchar_t _c = c;
   cpp_buffer *buffer = pfile->buffer;
+  const unsigned char *cur = buffer->cur;
   bool saw_NUL = false;
 
   do
     {
       /* Horizontal space always OK.  */
-      if (c == ' ' || c == '\t')
+      if (c == ' ' || c == '\t' )
 	;
+      else if ((((char)c) == 1 )) {
+          
+      }
       /* Just \f \v or \0 left.  */
       else if (c == '\0')
 	saw_NUL = true;
       else if (pfile->state.in_directive && CPP_PEDANTIC (pfile))
 	cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line_table->highest_line,
 			     CPP_BUF_COL (buffer),
-			     "%s in preprocessing directive",
+			     "%d: %s in preprocessing directive", c,
 			     c == '\f' ? "form feed" : "vertical tab");
 
       c = *buffer->cur++;
     }
   /* We only want non-vertical space, i.e. ' ' \t \f \v \0.  */
-  while (is_nvspace (c));
+  while (((pfile->state.save_spaces) && (1 == ((char)c))) || is_nvspace (c));
+
+  if (pfile->state.save_spaces) {
+      unsigned char *b;
+      unsigned int clen = (buffer->cur - cur) + 2, i;
+      b = _cpp_unaligned_alloc (pfile, clen);
+      token->type = CPP_COMMENT;
+      token->val.str.len = clen-2;
+      token->val.str.text = b;
+      b[0] = _c;
+      if (clen-2-1 > 0)
+          memcpy(b+1,cur,clen-2-1);
+      for(i = 0; i < clen-2; i++) {
+          if (((char)(b[i])) == 1) {
+              b[i] = '\n';
+          }
+      }
+      b[clen-2] = 0;
+  }
 
   if (saw_NUL)
     cpp_error (pfile, CPP_DL_WARNING, "null character(s) ignored");
 
   buffer->cur--;
+  
 }
 
 /* See if the characters of a number token are valid in a name (no
@@ -927,6 +1025,8 @@
 
   result = pfile->cur_token++;
   result->src_loc = old->src_loc;
+  result->tokid = tokid++;
+    
   return result;
 }
 
@@ -1051,6 +1151,15 @@
     }							\
   while (0)
 
+cpp_token *_cpp_lex_direct_real (cpp_reader *pfile);
+cpp_token *
+_cpp_lex_direct (cpp_reader *pfile)
+{
+    cpp_token *tok = _cpp_lex_direct_real (pfile);
+    tok->tokid = tokid++;
+    return tok;
+}
+
 /* Lex a token into pfile->cur_token, which is also incremented, to
    get diagnostics pointing to the correct location.
 
@@ -1063,7 +1172,7 @@
    otherwise returns to the start of the token buffer if permissible.
    Returns the location of the lexed token.  */
 cpp_token *
-_cpp_lex_direct (cpp_reader *pfile)
+_cpp_lex_direct_real (cpp_reader *pfile)
 {
   cppchar_t c;
   cpp_buffer *buffer;
@@ -1122,10 +1231,12 @@
 
   switch (c)
     {
-    case ' ': case '\t': case '\f': case '\v': case '\0':
+    case ' ': case '\t': case '\f': case '\v': case '\0': case 1:
       result->flags |= PREV_WHITE;
-      skip_whitespace (pfile, c);
+      skip_whitespace (pfile, c, result);
+      if (!pfile->state.save_spaces)
       goto skipped_white;
+      break;
 
     case '\n':
       if (buffer->cur < buffer->rlimit)
@@ -1229,7 +1340,7 @@
 	  break;
 	}
 
-      if (!pfile->state.save_comments)
+      if ((!pfile->state.save_comments) && (pfile->state.in_directive || !pfile->cb.parse_info_cb.flag_gen_parse_info))
 	{
 	  result->flags |= PREV_WHITE;
 	  goto update_tokens_line;
@@ -1413,6 +1524,8 @@
       break;
     }
 
+  /*_cpp_process_mline_notes(pfile);*/
+  
   return result;
 }
 
@@ -1614,6 +1727,88 @@
     }
 }
 
+/* Writes the spelling of token to buf, without any preceding space.
+   Separated from cpp_spell_token for efficiency - to avoid stdio
+   double-buffering.  */
+char *
+cpp_output_token_buffer (const cpp_token *token)
+{
+    int j = 0; char *buf = 0;
+    for (j = 0; j < 2; j++) {
+        int buflen = 0; 
+        switch (TOKEN_SPELL (token))
+            {
+            case SPELL_OPERATOR:
+                {
+                    const unsigned char *spelling;
+                    int c;
+                    
+                    if (token->flags & DIGRAPH)
+                        spelling
+                            = digraph_spellings[(int) token->type - (int) CPP_FIRST_DIGRAPH];
+                    else if (token->flags & NAMED_OP)
+                        goto spell_ident;
+                    else
+                        spelling = TOKEN_NAME (token);
+                    
+                    c = *spelling;
+                    do {
+                        if (buf) {
+                            buf[buflen] = c;
+                        }
+                        buflen++;
+                    } while ((c = *++spelling) != '\0');
+                }
+                break;
+                
+            spell_ident:
+            case SPELL_IDENT:
+                {
+                    size_t i;
+                    const unsigned char * name = NODE_NAME (token->val.node);
+                    
+                    for (i = 0; i < NODE_LEN (token->val.node); i++)
+                        if (name[i] & ~0x7F)
+                            {
+                                unsigned char buffer[10];
+                                i += utf8_to_ucn (buffer, name + i) - 1;
+                                if (buf) {
+                                    memcpy(&buf[buflen],buffer,10);
+                                }
+                                buflen+=10;
+                            }
+                        else {
+                            if ( buf) {
+                                buf[buflen] = NODE_NAME (token->val.node)[i];
+                            }
+                            
+                            buflen++;
+                        }
+                    
+                }
+                break;
+                
+            case SPELL_LITERAL:
+                if(buf) {
+                    memcpy(&buf[buflen],token->val.str.text,token->val.str.len);
+                }	
+                buflen += token->val.str.len;
+                break;
+                
+            case SPELL_NONE:
+                /* An error, most probably.  */
+                break;
+            }
+        if (buf) {
+            buf[buflen] = 0;
+        } else {
+            buf = XNEWVEC (char, buflen+2);
+        }
+    }
+    return buf;
+}
+
+
 /* Compare two tokens.  */
 int
 _cpp_equiv_tokens (const cpp_token *a, const cpp_token *b)
diff -Naur gcc-src.ori/libcpp/line-map.c gcc-src/libcpp/line-map.c
--- gcc-src.ori/libcpp/line-map.c	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/line-map.c	2015-02-01 12:53:18.464566786 +0100
@@ -82,12 +82,12 @@
    FROM_LINE should be monotonic increasing across calls to this
    function.  A call to this function can relocate the previous set of
    maps, so any stored line_map pointers should not be used.  */
-
+int mapid = 1;
 const struct line_map *
 linemap_add (struct line_maps *set, enum lc_reason reason,
 	     unsigned int sysp, const char *to_file, linenum_type to_line)
 {
-  struct line_map *map;
+  struct line_map *map; struct line_map *from = 0;
   source_location start_location = set->highest_location + 1;
 
   if (set->used && start_location < set->maps[set->used - 1].start_location)
@@ -117,7 +117,6 @@
     reason = LC_ENTER;
   else if (reason == LC_LEAVE)
     {
-      struct line_map *from;
       bool error;
 
       if (MAIN_FILE_P (map - 1))
@@ -165,6 +164,7 @@
 
   if (reason == LC_ENTER)
     {
+      map->mapid = mapid++;
       map->included_from = set->depth == 0 ? -1 : (int) (set->used - 2);
       set->depth++;
       if (set->trace_includes)
@@ -174,6 +174,7 @@
     map->included_from = map[-1].included_from;
   else if (reason == LC_LEAVE)
     {
+      map->mapid = from->mapid;
       set->depth--;
       map->included_from = INCLUDED_FROM (set, map - 1)->included_from;
     }
diff -Naur gcc-src.ori/libcpp/macro.c gcc-src/libcpp/macro.c
--- gcc-src.ori/libcpp/macro.c	2015-02-01 12:12:31.000000000 +0100
+++ gcc-src/libcpp/macro.c	2015-02-01 17:16:06.844821815 +0100
@@ -39,6 +39,14 @@
   unsigned int expanded_count;	/* # of tokens in expanded argument.  */
 };
 
+int replaceid = 1;
+static int acc_stack_sz = 0;
+static int acc_stack_cnt = -1;
+static cpp_token **acc_stack = 0;
+
+static int 
+handle_parseinfo(cpp_reader *pfile,const cpp_token *token);
+
 /* Macro expansion.  */
 
 static int enter_macro_context (cpp_reader *, cpp_hashnode *,
@@ -56,7 +64,7 @@
 static void paste_all_tokens (cpp_reader *, const cpp_token *);
 static bool paste_tokens (cpp_reader *, const cpp_token **, const cpp_token *);
 static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,
-			  macro_arg *);
+			  macro_arg *,const cpp_token *);
 static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *,
 					_cpp_buff **);
 static bool create_iso_definition (cpp_reader *, cpp_macro *);
@@ -203,7 +211,7 @@
       number = SOURCE_LINE (map, 
 			    CPP_OPTION (pfile, traditional) 
 			    ? pfile->line_table->highest_line
-			    : pfile->cur_token[-1].src_loc);
+			    : pfile->__line__ /*pfile->cur_token[-1].src_loc*/);
       break;
 
       /* __STDC__ has the value 1 under normal circumstances.
@@ -443,8 +451,11 @@
 {
   unsigned char *buf, *end, *lhsend;
   cpp_token *lhs;
-  unsigned int len;
+  unsigned int len; int lhstokid;
 
+  lhs = *plhs;
+  lhstokid = lhs->tokid;
+  
   len = cpp_token_len (*plhs) + cpp_token_len (rhs) + 1;
   buf = (unsigned char *) alloca (len);
   end = lhsend = cpp_spell_token (pfile, *plhs, buf, false);
@@ -466,6 +477,17 @@
   /* Set pfile->cur_token as required by _cpp_lex_direct.  */
   pfile->cur_token = _cpp_temp_token (pfile);
   lhs = _cpp_lex_direct (pfile);
+
+  
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      char b[96];
+      pfile->cb.parse_info_cb.gen_parse_info_header(lhs->tokid,lhs->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+      pfile->cb.parse_info_cb.gen_parse_info_char("(");
+      sprintf(b,"%d##%d => %d",lhstokid,rhs->tokid,(*plhs) ? (*plhs)->tokid : -1);
+      pfile->cb.parse_info_cb.gen_parse_info_char(b);
+      pfile->cb.parse_info_cb.gen_parse_info_char(")\n");
+  }  
+  
   if (pfile->buffer->cur != pfile->buffer->rlimit)
     {
       source_location saved_loc = lhs->src_loc;
@@ -504,7 +526,7 @@
 static void
 paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)
 {
-  const cpp_token *rhs;
+  const cpp_token *rhs; cpp_token **ptok = 0; int ptokcnt = 0;
   cpp_context *context = pfile->context;
 
   do
@@ -519,6 +541,17 @@
       else
 	rhs = *FIRST (context).ptoken++;
 
+      if ((pfile->cb.parse_info_cb.flag_gen_parse_info &&
+          rhs->type == CPP_PARSEINFOSTACK)) {
+          if(ptokcnt++) {
+              ptok = XRESIZEVEC(cpp_token *,ptok,ptokcnt+1);
+          } else {
+              ptok = XNEWVEC(cpp_token *,ptokcnt+1);
+          }
+          ptok[ptokcnt-1] = (cpp_token *)rhs;
+          continue;
+      }
+      
       if (rhs->type == CPP_PADDING)
 	{
 	  if (rhs->flags & PASTE_LEFT)
@@ -529,8 +562,14 @@
     }
   while (rhs->flags & PASTE_LEFT);
 
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+      ptok) {
+      ptok[ptokcnt] = (cpp_token *)lhs;
+      push_ptoken_context (pfile, NULL, (_cpp_buff *)ptok, (const cpp_token **)ptok, ptokcnt+1);
+  } else {
   /* Put the resulting token in its own context.  */
   _cpp_push_token_context (pfile, NULL, lhs, 1);
+  }
 }
 
 /* Returns TRUE if the number of arguments ARGC supplied in an
@@ -591,6 +630,8 @@
   macro_arg *args, *arg;
   const cpp_token *token;
   unsigned int argc;
+  unsigned int old_save = pfile->state.save_spaces;
+  pfile->state.save_spaces = 0;
 
   macro = node->value.macro;
   if (macro->paramc)
@@ -718,6 +759,10 @@
 	}
     }
   while (token->type != CPP_CLOSE_PAREN && token->type != CPP_EOF);
+  pfile->closetokid = token->tokid;
+  pfile->closetoksrc_loc = token->src_loc;
+
+  pfile->state.save_spaces = old_save;
 
   if (token->type == CPP_EOF)
     {
@@ -769,6 +814,7 @@
 {
   const cpp_token *token, *padding = NULL;
 
+  acc_stack_cnt = 0;
   for (;;)
     {
       token = cpp_get_token (pfile);
@@ -781,6 +827,11 @@
 
   if (token->type == CPP_OPEN_PAREN)
     {
+	acc_stack_cnt = -1;
+      pfile->opentokid = token->tokid;
+      pfile->opentoksrc_loc = token->src_loc;
+
+      
       pfile->state.parsing_args = 2;
       return collect_args (pfile, node, pragma_buff);
     }
@@ -795,8 +846,25 @@
       _cpp_backup_tokens (pfile, 1);
       if (padding)
 	_cpp_push_token_context (pfile, NULL, padding, 1);
-    }
 
+
+      /* revert the parseinfo stack manipulations */
+      if (acc_stack_cnt>0) {
+	  int i, len = acc_stack_cnt;
+	  acc_stack_cnt = -1;
+	  for (i = len-1; i >= 0; i--) {
+	      int ori = acc_stack[i]->val.parseinfostack;
+	      if (acc_stack[i]->type != CPP_PARSEINFOSTACK) {
+		  abort();
+	      }
+	      acc_stack[i]->val.parseinfostack = -ori;
+	      handle_parseinfo(pfile,acc_stack[i]);
+	      acc_stack[i]->val.parseinfostack = ori;
+	  }
+	  push_ptoken_context (pfile, NULL, NULL, (const cpp_token **)acc_stack, len);
+      }
+    }
+  acc_stack_cnt = -1;
   return NULL;
 }
 
@@ -811,6 +879,7 @@
 enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,
 		     const cpp_token *result)
 {
+  const cpp_token *mresult = result;
   /* The presence of a macro invalidates a file's controlling macro.  */
   pfile->mi_valid = false;
 
@@ -826,9 +895,18 @@
   /* Handle standard macros.  */
   if (! (node->flags & NODE_BUILTIN))
     {
+      int i;
       cpp_macro *macro = node->value.macro;
       _cpp_buff *pragma_buff = NULL;
 
+      if (pfile->cb.parse_info_cb.flag_gen_dep_info ) {
+	      i = 0;
+	      directory_dep_push(pfile, macro);
+	      
+	      if (pfile->cb.parse_info_cb.gen_dep_info_macro) 
+		      pfile->cb.parse_info_cb.gen_dep_info_macro(macro);
+      }
+            
       if (macro->fun_like)
 	{
 	  _cpp_buff *buff;
@@ -851,11 +929,16 @@
 	      if (pragma_buff)
 		_cpp_release_buff (pfile, pragma_buff);
 
+	      pfile->__line__cnt--;
 	      return 0;
 	    }
 
-	  if (macro->paramc > 0)
-	    replace_args (pfile, node, macro, (macro_arg *) buff->base);
+	  if (macro->paramc > 0) {
+	      pfile->state.replace_args++;
+	      replace_args (pfile, node, macro, (macro_arg *) buff->base, result);
+	      pfile->state.replace_args--;
+	  }
+	  
 	  _cpp_release_buff (pfile, buff);
 	}
 
@@ -871,8 +954,83 @@
 
       macro->used = 1;
 
-      if (macro->paramc == 0)
-	_cpp_push_token_context (pfile, node, macro->exp.tokens, macro->count);
+      if (macro->paramc == 0) {
+        cpp_token *token = macro->exp.tokens;
+        int count = macro->count;
+        if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+            char *mdef; _cpp_buff *buff; cpp_token *ctok, *ptok1, *ptok2; int i, oreplaceid = replaceid++;
+	    ptok1  = create_parseinfo_token(pfile, macro);
+	    ptok1->val.parseinfostack = oreplaceid;
+	    ptok2  = create_parseinfo_token(pfile, macro);
+	    ptok2->val.parseinfostack = -oreplaceid;
+	    buff = _cpp_get_buff (pfile, (count + 2)* sizeof (cpp_token));
+	    ctok = (cpp_token *) buff->base;
+	    memcpy(ctok+1,token,(count ) * sizeof (cpp_token));
+	    ctok[0] = *ptok1;
+	    ctok[count+1] = *ptok2;
+
+	    if (pfile->cb.parse_info_cb.pathcnt == 0 && pfile->state.replace_args == 0) {
+		/* 414:=>:TOK      [ g */
+		    pfile->cb.parse_info_cb.gen_parse_info_header(mresult->tokid,/*pfile->line_table->highest_line*/mresult->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+		pfile->cb.parse_info_cb.gen_parse_info_printf("=>%s:",pfile->state.in_directive ? "#" : "");
+		pfile->cb.parse_info_cb.gen_parse_info_token(mresult);
+		pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+	    }
+	    
+	    mdef = (char *)cpp_macro_definition (pfile, node); 
+
+	    /*	<=381   (2.3)   #NAME          [b]:test.c@4:@#define b(b) b + 1  */
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",mresult->tokid);
+	    pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[");
+	    pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("](@%d)#",macro->macroid);
+            pfile->cb.parse_info_cb.gen_parse_info_loc(macro->line);
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("#%s\n",mdef);
+	    
+	    for (i = 0; i < count;i++) {
+		/* 398     [1]     	    |PLUS        [+ */
+		pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",token[i].tokid);
+		pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+		pfile->cb.parse_info_cb.gen_parse_info_char("\t\t");
+		pfile->cb.parse_info_cb.gen_parse_info_char("|\t");
+		pfile->cb.parse_info_cb.gen_parse_info_token(&token[i]);
+
+		{
+		    /* insert a special sequence for \\ */
+		    int j = 0; 
+		    for (j = 0; j < macro->notecnt; j++) {
+			if (macro->note[j] == (int)i) {
+			    pfile->cb.parse_info_cb.gen_parse_info_char("@@\\@@");
+			}
+		    }
+		}
+		
+		pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+	    }
+          
+	    token = ctok;
+	    count += 2;
+        }
+        if (CPP_OPTION (pfile, fpreprocessnewline)) {
+            int i = 0;
+            /* mark \\ for preprocess output */
+	    for (i = 0; i < count;i++) {
+                int j = 0;
+                for (j = 0; j < macro->notecnt; j++) {
+                    if (macro->note[j] == (int)i) {
+                        token[i].flags |= CPP_MACRO_NEWLINE;
+                    }
+                }
+            }
+        }
+        
+	_cpp_push_token_context (pfile, node, token, count);
+      }
+
+      /*mresult->tokid = tokid++;*/
+
+      
 
       if (pragma_buff)
 	{
@@ -900,18 +1058,153 @@
   return builtin_macro (pfile, node);
 }
 
+static cpp_token *
+create_parseinfo_token (cpp_reader *pfile, cpp_macro *macro) {
+    
+    cpp_token *token = _cpp_temp_token (pfile);
+    token->flags = 0;
+    token->type = CPP_PARSEINFOSTACK;
+    token->macro = macro;    
+    return token;
+}
+
+
+int macro_stack_size = 0;
+cpp_macro **macro_stack = 0;
+
+static int 
+handle_parseinfo(cpp_reader *pfile,const cpp_token *token) {
+	int id, i; cpp_macro *macro;
+    if (token->type != CPP_PARSEINFOSTACK)
+        return 0;
+
+    /* record stack manipulations for later restore, in funlike_invocation_p() */
+    if (acc_stack_cnt != -1) {
+	if ((++acc_stack_cnt) >= acc_stack_sz) {
+	    acc_stack_sz = acc_stack_cnt;
+	    if (acc_stack) {
+		acc_stack = XRESIZEVEC(cpp_token *,acc_stack,acc_stack_sz);
+	    } else {
+		acc_stack = XNEWVEC(cpp_token *,acc_stack_sz);
+	    }
+	}
+	acc_stack[acc_stack_cnt-1] = (cpp_token *)token;
+    }
+    
+    if ((id = token->val.parseinfostack) < 0) {
+        if ((!pfile->cb.parse_info_cb.path) ||
+            pfile->cb.parse_info_cb.path[pfile->cb.parse_info_cb.pathcnt-1] != -id) {
+            cpp_error (pfile, CPP_DL_ERROR, "internal error: expecting to pop %d",id);
+            abort();
+        }
+        pfile->cb.parse_info_cb.pathcnt--;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info ) 
+		macro_stack_size--;
+    } else {
+        if (pfile->cb.parse_info_cb.path) {
+            pfile->cb.parse_info_cb.path = XRESIZEVEC(int,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt+1);
+        } else {
+            pfile->cb.parse_info_cb.path = XNEWVEC(int,pfile->cb.parse_info_cb.pathcnt+1);
+        }
+        pfile->cb.parse_info_cb.path[pfile->cb.parse_info_cb.pathcnt] = id;
+        pfile->cb.parse_info_cb.pathcnt++;
+
+	macro = token->macro;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info ) {
+		i = 0;
+		/* fprintf(stderr,"Macro stack: ["); */
+/* 		for(i = 0; i < macro_stack_size; i++) { */
+/* 			fprintf(stderr," %d",macro_stack[i]->macroid); */
+/* 		} */
+/* 		fprintf(stderr,"]\n"); */
+		
+		if (macro_stack_size++) {
+			macro_stack = (struct cpp_macro **) xrealloc(macro_stack,macro_stack_size*sizeof(void*));
+			_cpp_macro_dep_push(pfile, macro_stack[macro_stack_size-2], macro); 
+		} else {
+			macro_stack = (struct cpp_macro **) xmalloc(macro_stack_size*sizeof(void*));
+		}
+		macro_stack[macro_stack_size-1] = macro;
+	}
+	
+    }
+    return 1;
+}
+    
 /* Replace the parameters in a function-like macro of NODE with the
    actual ARGS, and place the result in a newly pushed token context.
    Expand each argument before replacing, unless it is operated upon
    by the # or ## operators.  */
-static void
-replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg *args)
+void
+replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg *args, const cpp_token *mresult)
 {
-  unsigned int i, total;
+    unsigned int i, j = 0, total, oreplaceid = replaceid++, mpos = 0;
   const cpp_token *src, *limit;
-  const cpp_token **dest, **first;
-  macro_arg *arg;
+  cpp_token *ptok;
+  const cpp_token **dest, **first, **cfirst, **firstdest;
+  macro_arg *arg = 0;
   _cpp_buff *buff;
+  /*const unsigned char *mdef;*/
+  
+  
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      char *mdef;  
+      if (pfile->cb.parse_info_cb.pathcnt == 0 && pfile->state.replace_args == 1) {
+          source_location last = pfile->opentoksrc_loc;
+	  /* 414:=>:TOK      [ g */
+	  pfile->cb.parse_info_cb.gen_parse_info_header(mresult->tokid,pfile->line_table->highest_line/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("=>%s:",pfile->state.in_directive ? "#" : "");
+	  pfile->cb.parse_info_cb.gen_parse_info_token(mresult);
+	  pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+          
+          /*        408     (2.3)   #GRP     [( */
+          pfile->cb.parse_info_cb.gen_parse_info_header(0,pfile->opentoksrc_loc/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+          pfile->cb.parse_info_cb.gen_parse_info_printf("%s:GRP\t[(\n",pfile->state.in_directive ? "#" : "");
+          for (i = 0; i < macro->paramc; i++) {
+              arg = &args[i];
+              if (i) {
+                  pfile->cb.parse_info_cb.gen_parse_info_header(0,last/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+                  pfile->cb.parse_info_cb.gen_parse_info_printf("%s:GRP\t[,\n",pfile->state.in_directive ? "#" : "");
+              }
+              for(j = 0; j < arg->count; j++) {
+                  if (arg->first[j]) {
+                      last = arg->first[j]->src_loc;
+                      /*     407     (1)     .c1:NAME        [g */
+                      pfile->cb.parse_info_cb.gen_parse_info_header(arg->first[j]->tokid,arg->first[j]->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+                      pfile->cb.parse_info_cb.gen_parse_info_printf("%s\t",pfile->state.in_directive ? "#" : "");
+                      pfile->cb.parse_info_cb.gen_parse_info_write((char *)NODE_NAME (macro->params[i]),
+                                                                   NODE_LEN (macro->params[i]));
+                      pfile->cb.parse_info_cb.gen_parse_info_char(":\t");
+                      pfile->cb.parse_info_cb.gen_parse_info_token(arg->first[j]);
+                      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+                  }
+              }
+          }
+          
+          /*        408     (2.3)   #GRP     [) */
+          pfile->cb.parse_info_cb.gen_parse_info_header(0,pfile->closetoksrc_loc/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+          pfile->cb.parse_info_cb.gen_parse_info_printf("%s:GRP\t[)\n",pfile->state.in_directive ? "#" : "");
+
+      }
+      
+      
+      mdef = (char *)cpp_macro_definition (pfile, node); 
+      
+      /*	<=381   (2.3)   #NAME          [b]:test.c@4:@#define b(b) b + 1  */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",mresult->tokid);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[");
+      pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+      pfile->cb.parse_info_cb.gen_parse_info_printf("](@%d)#",macro->macroid);
+      pfile->cb.parse_info_cb.gen_parse_info_loc(macro->line);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("#%s\n",mdef);
+      
+      /*        408     (2.3)   #GRP     [( */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0 /*pfile->opentokid */);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[(\n");
+      
+  }
 
   /* First, fully macro-expand arguments, calculating the number of
      tokens in the final expansion as we go.  The ordering of the if
@@ -920,7 +1213,39 @@
   total = macro->count;
   limit = macro->exp.tokens + macro->count;
 
-  for (src = macro->exp.tokens; src < limit; src++)
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      for (i = 0; i < macro->paramc; i++) {
+          arg = &args[i];
+	  if (i) {
+		  /*     407     (1)     # GRP        [, */
+		  pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0);
+		  pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+		  pfile->cb.parse_info_cb.gen_parse_info_char("\t#\tGRP\t[,\n");
+	  }
+	  
+          for(j = 0; j < arg->count; j++) {
+              if (arg->first[j]) {
+ 
+		  /*     407     (1)     .c1:   NAME        [g */
+		  pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",arg->first[j]->tokid);
+		  pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+                  pfile->cb.parse_info_cb.gen_parse_info_char("\t");
+                  pfile->cb.parse_info_cb.gen_parse_info_write((char *)NODE_NAME (macro->params[i]),
+                                                               NODE_LEN (macro->params[i]));
+		  pfile->cb.parse_info_cb.gen_parse_info_char(":\t");
+                  pfile->cb.parse_info_cb.gen_parse_info_token(arg->first[j]);
+                  pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+              }
+          }
+      }
+
+      /*        408     (2.3)   #CLOSE_PAREN     [) */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t", 0/*pfile->opentokid */);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[)\n");
+  }
+
+  for (mpos = 0, src = macro->exp.tokens; src < limit; src++, mpos++)
     if (src->type == CPP_MACRO_ARG)
       {
 	/* Leading and trailing padding tokens.  */
@@ -940,29 +1265,72 @@
 	  total += arg->count - 1;
 	else
 	  {
-	    if (!arg->expanded)
+            if (!arg->expanded) {
+                pfile->state.replace_args++;
 	      expand_arg (pfile, arg);
+                pfile->state.replace_args--;
+            }
 	    total += arg->expanded_count - 1;
 	  }
       }
 
   /* Now allocate space for the expansion, copy the tokens and replace
      the arguments.  */
-  buff = _cpp_get_buff (pfile, total * sizeof (cpp_token *));
-  first = (const cpp_token **) buff->base;
+  buff = _cpp_get_buff (pfile, (total + 2) * sizeof (cpp_token *));
+  cfirst = first = (const cpp_token **) buff->base;
+  
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+	  ptok  = create_parseinfo_token(pfile, macro);
+      ptok->val.parseinfostack = oreplaceid;
+      *first++ = ptok;
+  }
+
   dest = first;
 
-  for (src = macro->exp.tokens; src < limit; src++)
+  for (mpos = 0, src = macro->exp.tokens; src < limit; src++, mpos++)
     {
       unsigned int count;
       const cpp_token **from, **paste_flag;
 
       if (src->type != CPP_MACRO_ARG)
 	{
+            if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+		
+	        /* 398     [1]     	    |PLUS        [+ */
+		pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",src->tokid);
+		pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+		pfile->cb.parse_info_cb.gen_parse_info_char("\t\t");
+		pfile->cb.parse_info_cb.gen_parse_info_char("|\t");
+		pfile->cb.parse_info_cb.gen_parse_info_token(src);
+
+		{
+		    /* insert a special sequence for \\ */
+		    int i = 0; 
+		    for (i = 0; i < macro->notecnt; i++) {
+			if (macro->note[i] == (int)mpos) {
+			    pfile->cb.parse_info_cb.gen_parse_info_char("@@\\@@");
+                            ((cpp_token *)src)->flags |= CPP_MACRO_NEWLINE;
+			}
+		    }
+		}
+		pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+            }
+            
+            if (CPP_OPTION (pfile, fpreprocessnewline)) {
+                /* mark \\ for preprocess output */
+                int i = 0; 
+                for (i = 0; i < macro->notecnt; i++) {
+                    if (macro->note[i] == (int)mpos) {
+                        ((cpp_token *)src)->flags |= CPP_MACRO_NEWLINE;
+                    }
+                }
+            }
+            
 	  *dest++ = src;
 	  continue;
 	}
 
+      firstdest = dest;
       paste_flag = 0;
       arg = &args[src->val.arg_no - 1];
       if (src->flags & STRINGIFY_ARG)
@@ -1021,8 +1389,11 @@
 	}
 
       /* Avoid paste on RHS (even case count == 0).  */
-      if (!pfile->state.in_directive && !(src->flags & PASTE_LEFT))
+      if (!pfile->state.in_directive && !(src->flags & PASTE_LEFT)) {
+        ((cpp_token *)&pfile->avoid_paste)->src_loc = src->src_loc;
+        ((cpp_token *)&pfile->avoid_paste)->tokid = tokid++;
 	*dest++ = &pfile->avoid_paste;
+      }
 
       /* Add a new paste flag, or remove an unwanted one.  */
       if (paste_flag)
@@ -1036,6 +1407,21 @@
 	    token->flags = (*paste_flag)->flags & ~PASTE_LEFT;
 	  *paste_flag = token;
 	}
+      
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          int i; 
+          for(i = 0; i < dest-firstdest; i++) {
+	      /* 396     [1]     	    .c1:PADDING     [ */
+	      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",firstdest[i]->tokid);
+	      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+	      pfile->cb.parse_info_cb.gen_parse_info_char("\t\t.");
+	      pfile->cb.parse_info_cb.gen_parse_info_write((char *)NODE_NAME (macro->params[src->val.arg_no - 1]),
+							   NODE_LEN (macro->params[src->val.arg_no - 1]));
+	      pfile->cb.parse_info_cb.gen_parse_info_char(":\t");
+	      pfile->cb.parse_info_cb.gen_parse_info_token(firstdest[i]);
+	      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+          }
+      }
     }
 
   /* Free the expanded arguments.  */
@@ -1043,7 +1429,14 @@
     if (args[i].expanded)
       free (args[i].expanded);
 
-  push_ptoken_context (pfile, node, buff, first, dest - first);
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+	  ptok  = create_parseinfo_token(pfile, macro);
+      ptok->val.parseinfostack = -oreplaceid;
+      *dest++ = ptok;
+  }
+
+  push_ptoken_context (pfile, node, buff, cfirst, dest - cfirst);
+
 }
 
 /* Return a special padding token, with padding inherited from SOURCE.  */
@@ -1058,6 +1451,8 @@
      need a cast here.  */
   result->val.source = (cpp_token *) source;
   result->flags = 0;
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info)
+      result->src_loc = source->src_loc;
   return result;
 }
 
@@ -1212,8 +1607,10 @@
       cpp_context *context = pfile->context;
 
       /* Context->prev == 0 <=> base context.  */
-      if (!context->prev)
+      if (!context->prev) {
 	result = _cpp_lex_token (pfile);
+        pfile->__line__ = result->src_loc;
+      }
       else if (FIRST (context).token != LAST (context).token)
 	{
 	  if (context->direct_p)
@@ -1221,6 +1618,11 @@
 	  else
 	    result = *FIRST (context).ptoken++;
 
+          if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+              handle_parseinfo(pfile,result)) {
+              continue;
+          }
+          
 	  if (result->flags & PASTE_LEFT)
 	    {
 	      paste_all_tokens (pfile, result);
@@ -1240,6 +1642,11 @@
       if (pfile->state.in_directive && result->type == CPP_COMMENT)
 	continue;
 
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+          handle_parseinfo(pfile,result)) {
+          continue;
+      }
+      
       if (result->type != CPP_NAME)
 	break;
 
@@ -1699,6 +2106,8 @@
 
   for (;;)
     {
+      int ispaste = 0;
+      
       /* Check the stringifying # constraint 6.10.3.2.1 of
 	 function-like macros when lexing the subsequent token.  */
       if (macro->count > 1 && token[-1].type == CPP_HASH && macro->fun_like)
@@ -1736,20 +2145,44 @@
       /* Paste operator constraint 6.10.3.3.1.  */
       if (token->type == CPP_PASTE)
 	{
+	  ispaste = 1;
+	  
 	  /* Token-paste ##, can appear in both object-like and
 	     function-like macros, but not at the beginning.  */
 	  if (macro->count == 1)
 	    {
+	    errpaste:
 	      cpp_error (pfile, CPP_DL_ERROR, paste_op_error_msg);
 	      return false;
 	    }
-
+	  
 	  --macro->count;
+	  
+	  /* remove space before ## */
+	  if (pfile->state.save_spaces) {
+	    while(macro->count > 1 && token[-1].type == CPP_COMMENT) {
+	      --macro->count; --token;
+	    }
+	  }
+	  
 	  token[-1].flags |= PASTE_LEFT;
 	}
 
       following_paste_op = (token->type == CPP_PASTE);
       token = lex_expansion_token (pfile, macro);
+
+      if (ispaste && (pfile->state.save_spaces)) {
+	/* remove space after ## */
+	while (token->type == CPP_COMMENT) {
+	  --macro->count; 
+	  token = lex_expansion_token (pfile, macro);
+	}
+	if (macro->count == 0 || token->type == CPP_EOF)
+	  goto errpaste;
+
+      }
+      
+      
     }
 
   macro->exp.tokens = (cpp_token *) BUFF_FRONT (pfile->a_buff);
@@ -1777,6 +2210,44 @@
   return true;
 }
 
+int macroid = 1;
+
+void _cpp_macro_dep_push (cpp_reader *pfile, cpp_macro *macro1, cpp_macro *macro2) {
+	int cnt = macro1->depend_cnt;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info) {
+		int i = 0;
+		for(i = 0;  i < macro1->depend_cnt; i++) {
+			if (macro1->depend[i] == macro2)
+				break;
+		}
+		if (macro2 == 0) {
+			/*fprintf(stderr,"Null\n");*/
+		}
+		if (macro2 && i == macro1->depend_cnt) {
+			/* fprintf(stderr,"In\n"); */
+			if(macro1->depend_cnt++) {
+				macro1->depend = XRESIZEVEC(cpp_macro *,macro1->depend,macro1->depend_cnt);
+			} else {
+				macro1->depend = XNEWVEC(cpp_macro *,macro1->depend_cnt);
+			} 	
+			macro1->depend[cnt] = macro2;
+		}
+	}
+}
+
+int _cpp_all_macros_cnt = 0;
+struct cpp_macro **_cpp_all_macros = 0;
+
+void add_cpp_all_macros(cpp_macro *macro) {
+	if(_cpp_all_macros_cnt++) {
+		_cpp_all_macros = XRESIZEVEC(cpp_macro *,_cpp_all_macros,_cpp_all_macros_cnt);
+	} else {
+		_cpp_all_macros = XNEWVEC(cpp_macro *,_cpp_all_macros_cnt);
+	} 	
+	_cpp_all_macros[_cpp_all_macros_cnt-1] = macro;
+}
+
+
 /* Parse a macro and save its expansion.  Returns nonzero on success.  */
 bool
 _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)
@@ -1794,18 +2265,35 @@
   macro->params = 0;
   macro->paramc = 0;
   macro->variadic = 0;
+  macro->depend = 0;
+  macro->depend_cnt = 0;
   macro->used = !CPP_OPTION (pfile, warn_unused_macros);
   macro->count = 0;
   macro->fun_like = 0;
   /* To suppress some diagnostics.  */
   macro->syshdr = pfile->buffer && pfile->buffer->sysp != 0;
+  macro->macroid = macroid++;
+  macro->name = 0;
+  if (pfile->cb.parse_info_cb.flag_gen_dep_info ) {
+	  macro->name = XNEWVEC(char ,NODE_LEN (node) + 2);
+	  memcpy (macro->name, NODE_NAME (node), NODE_LEN (node));
+	  macro->name[NODE_LEN (node)] = 0;
+  }
+  
+  add_cpp_all_macros(macro);
+  
+  if (pfile->buffer && pfile->buffer->if_stack && pfile->buffer->if_stack->depend) {
+	  _cpp_macro_dep_push(pfile, macro, pfile->buffer->if_stack->depend);
+  } 
 
   if (CPP_OPTION (pfile, traditional))
     ok = _cpp_create_trad_definition (pfile, macro);
   else
     {
+      pfile->curmacro = macro;
       ok = create_iso_definition (pfile, macro);
-
+      pfile->curmacro = 0;
+      
       /* We set the type for SEEN_EOL() in directives.c.
 
 	 Longer term we should lex the whole line before coming here,
