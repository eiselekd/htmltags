diff -Naurb gcc-4.2.1.ori/libcpp/directives.c gcc-4.2.1/libcpp/directives.c
--- gcc-4.2.1.ori/libcpp/directives.c	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/directives.c	2014-03-13 18:59:11 +0000
@@ -26,17 +26,8 @@
 #include "mkdeps.h"
 #include "obstack.h"
 
-/* Stack of conditionals currently in progress
-   (including both successful and failing conditionals).  */
-struct if_stack
-{
-  struct if_stack *next;
-  unsigned int line;		/* Line where condition started.  */
-  const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */
-  bool skip_elses;		/* Can future #else / #elif be skipped?  */
-  bool was_skipping;		/* If were skipping on entry.  */
-  int type;			/* Most recent conditional for diagnostics.  */
-};
+
+extern int macroid;
 
 /* Contains a registered pragma or pragma namespace.  */
 typedef void (*pragma_cb) (cpp_reader *);
@@ -88,7 +79,7 @@
 };
 
 /* Forward declarations.  */
-
+struct cpp_macro *push_depend (cpp_reader *pfile, const char *n);
 static void skip_rest_of_line (cpp_reader *);
 static void check_eol (cpp_reader *);
 static void start_directive (cpp_reader *);
@@ -98,11 +89,11 @@
 static void run_directive (cpp_reader *, int, const char *, size_t);
 static char *glue_header_name (cpp_reader *);
 static const char *parse_include (cpp_reader *, int *, const cpp_token ***);
-static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *);
+static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *,struct cpp_macro *);
 static unsigned int read_flag (cpp_reader *, unsigned int);
 static int strtoul_for_line (const uchar *, unsigned int, unsigned long *);
 static void do_diagnostic (cpp_reader *, int, int);
-static cpp_hashnode *lex_macro_node (cpp_reader *);
+static cpp_hashnode *lex_macro_node (cpp_reader *, cpp_token **);
 static int undefine_macros (cpp_reader *, cpp_hashnode *, void *);
 static void do_include_common (cpp_reader *, enum include_type);
 static struct pragma_entry *lookup_pragma_entry (struct pragma_entry *,
@@ -204,6 +195,10 @@
   if (! SEEN_EOL ())
     while (_cpp_lex_token (pfile)->type != CPP_EOF)
       ;
+
+  /* a #include a with a expandsion to "file.h" will have context open */
+  pfile->cb.parse_info_cb.pathcnt = 0;
+
 }
 
 /* Ensure there are no stray tokens at the end of a directive.  */
@@ -262,6 +257,8 @@
   /* Setup in-directive state.  */
   pfile->state.in_directive = 1;
   pfile->state.save_comments = 0;
+  pfile->state.save_spaces = 0;
+  pfile->state.skipping_old = pfile->state.skipping;
   pfile->directive_result.type = CPP_PADDING;
 
   /* Some handlers need the position of the # for diagnostics.  */
@@ -293,9 +290,19 @@
 	}
     }
 
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+      pfile->state.skipping_old != pfile->state.skipping) {
+      pfile->cb.parse_info_cb.gen_parse_info_loc_line(pfile->directive_line);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("->");
+      pfile->cb.parse_info_cb.gen_parse_info_loc_line(pfile->line_table->highest_line);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#:%d->%d\n",pfile->state.skipping_old,pfile->state.skipping);
+  }
+
   /* Restore state.  */
   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);
+  pfile->state.save_spaces = CPP_OPTION (pfile, preserve_spaces);
   pfile->state.in_directive = 0;
+  pfile->state.dep = 0;
   pfile->state.in_expression = 0;
   pfile->state.angled_headers = 0;
   pfile->directive = 0;
@@ -504,9 +511,10 @@
 /* Checks for validity the macro name in #define, #undef, #ifdef and
    #ifndef directives.  */
 static cpp_hashnode *
-lex_macro_node (cpp_reader *pfile)
+lex_macro_node (cpp_reader *pfile, cpp_token **rtoken)
 {
   const cpp_token *token = _cpp_lex_token (pfile);
+  *rtoken = (cpp_token *)token;
 
   /* The token immediately after #define must be an identifier.  That
      identifier may not be "defined", per C99 6.10.8p4.
@@ -542,7 +550,9 @@
 static void
 do_define (cpp_reader *pfile)
 {
-  cpp_hashnode *node = lex_macro_node (pfile);
+  cpp_token *tok;
+  cpp_hashnode *node = lex_macro_node (pfile, &tok);
+  cpp_macro *macro;
 
   if (node)
     {
@@ -550,10 +560,26 @@
 	 then re-enable saving of comments.  */
       pfile->state.save_comments =
 	! CPP_OPTION (pfile, discard_comments_in_macro_exp);
+      pfile->state.save_spaces =
+          CPP_OPTION (pfile, preserve_spaces);
 
-      if (_cpp_create_definition (pfile, node))
+      if (_cpp_create_definition (pfile, node)) {	      
 	if (pfile->cb.define)
 	  pfile->cb.define (pfile, pfile->directive_line, node);
+
+        macro = node->value.macro;
+	if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+            char *mdef;  
+            mdef = (char *)cpp_macro_definition (pfile, node); 
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("#define(@%d) \t",macro->macroid);
+	    pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+	    pfile->cb.parse_info_cb.gen_parse_info_printf(":[");
+	    pfile->cb.parse_info_cb.gen_parse_info_loc(pfile->directive_line);
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("]-[");
+	    pfile->cb.parse_info_cb.gen_parse_info_loc(pfile->line_table->highest_line);
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("]:%s\n",mdef);
+	}
+      }
     }
 }
 
@@ -561,7 +587,8 @@
 static void
 do_undef (cpp_reader *pfile)
 {
-  cpp_hashnode *node = lex_macro_node (pfile);
+  cpp_token *tok;
+  cpp_hashnode *node = lex_macro_node (pfile, &tok);
 
   if (node)
     {
@@ -740,6 +767,7 @@
       /* Get out of macro context, if we are.  */
       skip_rest_of_line (pfile);
 
+	    
       if (pfile->cb.include)
 	pfile->cb.include (pfile, pfile->directive_line,
 			   pfile->directive->name, fname, angle_brackets,
@@ -1599,25 +1627,64 @@
 	       "_Pragma takes a parenthesized string literal");
 }
 
+void directory_dep_push(cpp_reader *pfile, cpp_macro *m) {
+	if (pfile->state.in_directive && 
+	    pfile->state.dep ) {
+		_cpp_macro_dep_push (pfile, pfile->state.dep, m);
+	}
+}
+
 /* Handle #ifdef.  */
 static void
 do_ifdef (cpp_reader *pfile)
 {
   int skip = 1;
+  cpp_token *tok;
+  struct cpp_macro *dep = push_depend (pfile,"<ifdef>");
 
   if (! pfile->state.skipping)
     {
-      const cpp_hashnode *node = lex_macro_node (pfile);
+      const cpp_hashnode *node = lex_macro_node (pfile, &tok);
 
       if (node)
 	{
 	  skip = node->type != NT_MACRO;
-	  _cpp_mark_macro_used (node);
+	  _cpp_mark_macro_used (pfile,node);
 	  check_eol (pfile);
 	}
+         
+      if (tok && pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          int oreplaceid = replaceid++;
+          cpp_token num;
+          
+          parse_info_directive_token(pfile, (cpp_token *)tok);
+          
+          /*	<=381   (2.3)   #NAME          [defined]:test.c@4:@#define(a)  */
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",tok->tokid);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[");
+          pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (tok->val.node), (int)NODE_LEN (tok->val.node));
+          pfile->cb.parse_info_cb.gen_parse_info_printf("](@0)#");
+          pfile->cb.parse_info_cb.gen_parse_info_loc(tok->src_loc);
+          pfile->cb.parse_info_cb.gen_parse_info_printf("#defined(");
+          pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (tok->val.node), (int)NODE_LEN (tok->val.node));
+          pfile->cb.parse_info_cb.gen_parse_info_printf(")\n");
+          
+          /*     407     [1]     .c1:   NAME        [g */
+          num.type = CPP_NUMBER;
+          num.flags = 0;
+          num.val.str.len = 1;
+          num.val.str.text = skip ? (const unsigned char *)"0" : (const unsigned char *)"1";
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",tok->tokid);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+          pfile->cb.parse_info_cb.gen_parse_info_char("\tp:\t");
+          pfile->cb.parse_info_cb.gen_parse_info_token(&num);
+          pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+      }
+         
     }
 
-  push_conditional (pfile, skip, T_IFDEF, 0);
+  push_conditional (pfile, skip, T_IFDEF, 0, dep);
 }
 
 /* Handle #ifndef.  */
@@ -1626,20 +1693,22 @@
 {
   int skip = 1;
   const cpp_hashnode *node = 0;
+  cpp_token *tok;
+  struct cpp_macro *dep = push_depend (pfile,"<ifndef>");
 
   if (! pfile->state.skipping)
     {
-      node = lex_macro_node (pfile);
+        node = lex_macro_node (pfile, &tok);
 
       if (node)
 	{
 	  skip = node->type == NT_MACRO;
-	  _cpp_mark_macro_used (node);
+	  _cpp_mark_macro_used (pfile,node);
 	  check_eol (pfile);
 	}
     }
 
-  push_conditional (pfile, skip, T_IFNDEF, node);
+  push_conditional (pfile, skip, T_IFNDEF, node, dep);
 }
 
 /* _cpp_parse_expr puts a macro in a "#if !defined ()" expression in
@@ -1651,11 +1720,12 @@
 do_if (cpp_reader *pfile)
 {
   int skip = 1;
+  struct cpp_macro *dep = push_depend (pfile,"<if>");
 
   if (! pfile->state.skipping)
     skip = _cpp_parse_expr (pfile) == false;
 
-  push_conditional (pfile, skip, T_IF, pfile->mi_ind_cmacro);
+  push_conditional (pfile, skip, T_IF, pfile->mi_ind_cmacro, dep);
 }
 
 /* Flip skipping state if appropriate and continue without changing
@@ -1756,13 +1826,28 @@
     }
 }
 
+struct cpp_macro *push_depend (cpp_reader *pfile, const char *n) {
+	struct cpp_macro *depend = 0;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info) {
+		depend =   (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));
+		memset(depend, 0, sizeof(cpp_macro));
+		depend->line = pfile->directive_line;
+		depend->macroid = macroid++;
+		depend->name = xstrdup(n);
+		add_cpp_all_macros(depend);
+		
+		pfile->state.dep = depend;
+	}
+	return depend;
+}
+
 /* Push an if_stack entry for a preprocessor conditional, and set
    pfile->state.skipping to SKIP.  If TYPE indicates the conditional
    is #if or #ifndef, CMACRO is a potentially controlling macro, and
    we need to check here that we are at the top of the file.  */
 static void
 push_conditional (cpp_reader *pfile, int skip, int type,
-		  const cpp_hashnode *cmacro)
+		  const cpp_hashnode *cmacro, struct cpp_macro *dep)
 {
   struct if_stack *ifs;
   cpp_buffer *buffer = pfile->buffer;
@@ -1773,6 +1858,17 @@
   ifs->skip_elses = pfile->state.skipping || !skip;
   ifs->was_skipping = pfile->state.skipping;
   ifs->type = type;
+  ifs->depend = dep;
+  
+  if (pfile->cb.parse_info_cb.flag_gen_dep_info) {
+	  if (dep &&
+	      ifs->next &&
+	      ifs->next->depend) {
+		  _cpp_macro_dep_push (pfile, dep, ifs->next->depend);
+	  }
+	  
+  }
+  
   /* This condition is effectively a test for top-of-file.  */
   if (pfile->mi_valid && pfile->mi_cmacro == 0)
     ifs->mi_cmacro = cmacro;
@@ -2070,6 +2166,9 @@
 void
 cpp_undef (cpp_reader *pfile, const char *macro)
 {
+	/* todo: for dep-info, record all macros with same name (undef and subsequently redefined)
+	   and add dependencies of _all_ instead only the last one */
+
   size_t len = strlen (macro);
   char *buf = (char *) alloca (len + 1);
   memcpy (buf, macro, len);
diff -Naurb gcc-4.2.1.ori/libcpp/expr.c gcc-4.2.1/libcpp/expr.c
--- gcc-4.2.1.ori/libcpp/expr.c	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/expr.c	2014-03-13 18:59:11 +0000
@@ -35,6 +35,8 @@
   enum cpp_ttype op;
 };
 
+extern int replaceid; /* macro.c */
+
 /* Some simple utility routines on double integers.  */
 #define num_zerop(num) ((num.low | num.high) == 0)
 #define num_eq(num1, num2) (num1.low == num2.low && num1.high == num2.high)
@@ -57,7 +59,7 @@
 static cpp_num num_rshift (cpp_num, size_t, size_t);
 
 static cpp_num append_digit (cpp_num, int, int, size_t);
-static cpp_num parse_defined (cpp_reader *);
+static cpp_num parse_defined (cpp_reader *, int );
 static cpp_num eval_token (cpp_reader *, const cpp_token *);
 static struct op *reduce (cpp_reader *, struct op *, enum cpp_ttype);
 static unsigned int interpret_float_suffix (const uchar *, size_t);
@@ -76,6 +78,23 @@
   do { cpp_error (pfile, CPP_DL_ERROR, msgid, arg); goto syntax_error; } \
   while(0)
 
+void 
+parse_info_directive_token (cpp_reader *pfile, cpp_token *token) {
+    if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+        pfile->cb.parse_info_cb.gen_parse_info_updateloc(&pfile->cb.parse_info_cb, token->src_loc,0);
+
+#ifdef USE_MAPPED_LOCATION
+	fprintf(stderr,"--enable-mapped-location for -fparse-info not implemeneted yet\n");
+	abort();
+#else 
+	pfile->cb.parse_info_cb.gen_parse_info_header(token->tokid,token->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+#endif
+	pfile->cb.parse_info_cb.gen_parse_info_printf("#:",token->tokid);
+        pfile->cb.parse_info_cb.gen_parse_info_token (token);
+        pfile->cb.parse_info_cb.gen_parse_info_char ("\n");
+    }
+}
+
 /* Subroutine of cpp_classify_number.  S points to a float suffix of
    length LEN, possibly zero.  Returns 0 for an invalid suffix, or a
    flag vector describing the suffix.  */
@@ -464,32 +483,46 @@
 
 /* Handle meeting "defined" in a preprocessor expression.  */
 static cpp_num
-parse_defined (cpp_reader *pfile)
+parse_defined (cpp_reader *pfile, int tokid)
 {
   cpp_num result;
   int paren = 0;
   cpp_hashnode *node = 0;
-  const cpp_token *token;
+  const cpp_token *token, *name_token = 0;
   cpp_context *initial_context = pfile->context;
 
   /* Don't expand macros.  */
   pfile->state.prevent_expansion++;
 
   token = cpp_get_token (pfile);
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      parse_info_directive_token(pfile, (cpp_token *)token);
+  }
+
   if (token->type == CPP_OPEN_PAREN)
     {
       paren = 1;
       token = cpp_get_token (pfile);
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          parse_info_directive_token(pfile, (cpp_token *)token);
+      }
     }
 
   if (token->type == CPP_NAME)
     {
+      const cpp_token *l = 0;
+      name_token = token;
       node = token->val.node;
-      if (paren && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)
+      if (paren) {
+          if ((!(l = cpp_get_token (pfile))) || (l->type  != CPP_CLOSE_PAREN))
 	{
 	  cpp_error (pfile, CPP_DL_ERROR, "missing ')' after \"defined\"");
 	  node = 0;
 	}
+          if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+              parse_info_directive_token(pfile, (cpp_token *)l);
+          }
+      }
     }
   else
     {
@@ -514,7 +547,7 @@
 	cpp_error (pfile, CPP_DL_WARNING,
 		   "this use of \"defined\" may not be portable");
 
-      _cpp_mark_macro_used (node);
+      _cpp_mark_macro_used (pfile,node);
 
       /* A possible controlling macro of the form #if !defined ().
 	 _cpp_parse_expr checks there was no other junk on the line.  */
@@ -527,6 +560,66 @@
   result.high = 0;
   result.overflow = false;
   result.low = node && node->type == NT_MACRO;
+
+  if (name_token && pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      int oreplaceid = replaceid++;
+      cpp_macro *macro = node->value.macro;
+      cpp_token num;
+      /*	<=381   (2.3)   #NAME          [defined]:test.c@4:@#define(a)  */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",tokid);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[defined](@0)#",0);
+      pfile->cb.parse_info_cb.gen_parse_info_loc(name_token->src_loc);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("#defined(");
+      pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+      pfile->cb.parse_info_cb.gen_parse_info_printf(")\n");
+      
+      /*        408     (2.3)   #GRP     [( */
+      if (paren) {
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0 /*pfile->opentokid */);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[(\n");
+      }
+      
+      /*     407     (1)     .c1:   NAME        [g */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",name_token->tokid);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_char("\tp:\t");
+      pfile->cb.parse_info_cb.gen_parse_info_token(name_token);
+      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+      
+      /*        408     (2.3)   #GRP     [) */
+      if (paren) {
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0 /*pfile->opentokid */);
+          pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+          pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[)\n");
+      }
+      if (result.low) {
+	  /* macro exists */
+	  int oreplaceid = replaceid++;
+	  char *mdef = (char *)cpp_macro_definition (pfile, node); 
+	  
+	  /*	<=381   (2.3)   #NAME          [defined]:test.c@4:@#define(a)  */
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",name_token->tokid);
+	  pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[",0);
+	  pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("](@%d)#",macro ? macro->macroid : 0);
+	  pfile->cb.parse_info_cb.gen_parse_info_loc(macro->line);
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("#%s\n",mdef);
+      
+      }
+      /*     407     [1]     .c1:   NAME        [g */
+      num.type = CPP_NUMBER;
+      num.flags = 0;
+      num.val.str.len = 1;
+      num.val.str.text = result.low ? (const unsigned char *)"1" : (const unsigned char *)"0";
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0/*name_token->tokid*/);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+      pfile->cb.parse_info_cb.gen_parse_info_char("\tp:\t");
+      pfile->cb.parse_info_cb.gen_parse_info_token(&num);
+      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+  }
   return result;
 }
 
@@ -589,7 +682,7 @@
 
     case CPP_NAME:
       if (token->val.node == pfile->spec_nodes.n_defined)
-	return parse_defined (pfile);
+          return parse_defined (pfile,token->tokid);
       else if (CPP_OPTION (pfile, cplusplus)
 	       && (token->val.node == pfile->spec_nodes.n_true
 		   || token->val.node == pfile->spec_nodes.n_false))
@@ -721,6 +814,14 @@
       op.token = cpp_get_token (pfile);
       op.op = op.token->type;
 
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          if (op.token->type == CPP_NAME && 
+              op.token->val.node == pfile->spec_nodes.n_defined) {
+              ((cpp_token *)op.token)->tokid = tokid++;
+          }
+          parse_info_directive_token(pfile, (cpp_token *)op.token);
+      }
+      
       switch (op.op)
 	{
 	  /* These tokens convert into values.  */
@@ -749,9 +850,11 @@
 	  break;
 
 	default:
-	  if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ)
+            if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ) {
+                printf("error: typ:%d, comment:%d,%d%d in_dir: %d\n", op.op, op.op == CPP_COMMENT, CPP_COMMENT, CPP_OTHER, pfile->state.in_directive);
 	    SYNTAX_ERROR2 ("token \"%s\" is not valid in preprocessor expressions",
 			   cpp_token_as_text (pfile, op.token));
+            }
 	  break;
 	}
 
diff -Naurb gcc-4.2.1.ori/libcpp/files.c gcc-4.2.1/libcpp/files.c
--- gcc-4.2.1.ori/libcpp/files.c	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/files.c	2014-03-13 18:59:11 +0000
@@ -701,8 +701,15 @@
   cpp_buffer *buffer;
   int sysp;
 
-  if (!should_stack_file (pfile, file, import))
+  if (!should_stack_file (pfile, file, import)) {
+      if (file->cmacro && file->cmacro->type == NT_MACRO) {
+          if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+              pfile->cb.parse_info_cb.gen_parse_info_loc_line(pfile->line_table->highest_line);
+              pfile->cb.parse_info_cb.gen_parse_info_printf("@# include +- %s\n",file->path);
+          }
+      }
       return false;
+  }
 
   if (pfile->buffer == NULL || file->dir == NULL)
     sysp = 0;
diff -Naurb gcc-4.2.1.ori/libcpp/include/cpp-id-data.h gcc-4.2.1/libcpp/include/cpp-id-data.h
--- gcc-4.2.1.ori/libcpp/include/cpp-id-data.h	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/include/cpp-id-data.h	2014-03-13 18:59:11 +0000
@@ -75,4 +75,15 @@
 
   /* Indicate which field of 'exp' is in use.  */
   unsigned int traditional : 1;
+
+  int * GTY ((length ("%h.notecnt"))) note;
+  int notecnt;
+  
+  int macroid;
+
+  struct cpp_macro ** GTY((length("%h.depend_cnt"))) depend;
+  int depend_cnt;
+  
+  char *name;
+  
 };
diff -Naurb gcc-4.2.1.ori/libcpp/include/cpplib.h gcc-4.2.1/libcpp/include/cpplib.h
--- gcc-4.2.1.ori/libcpp/include/cpplib.h	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/include/cpplib.h	2014-03-13 18:59:11 +0000
@@ -57,88 +57,89 @@
    add or remove anything in the first group.  */
 
 #define TTYPE_TABLE							\
-  OP(EQ,		"=")						\
-  OP(NOT,		"!")						\
-  OP(GREATER,		">")	/* compare */				\
-  OP(LESS,		"<")						\
-  OP(PLUS,		"+")	/* math */				\
-  OP(MINUS,		"-")						\
-  OP(MULT,		"*")						\
-  OP(DIV,		"/")						\
-  OP(MOD,		"%")						\
-  OP(AND,		"&")	/* bit ops */				\
-  OP(OR,		"|")						\
-  OP(XOR,		"^")						\
-  OP(RSHIFT,		">>")						\
-  OP(LSHIFT,		"<<")						\
+  OP(AOP, EQ,		"=")						\
+  OP(AOP, NOT,		"!")						\
+  OP(AOP, GREATER,		">")	/* compare */				\
+  OP(AOP, LESS,		"<")						\
+  OP(AOP, PLUS,		"+")	/* math */				\
+  OP(AOP, MINUS,		"-")						\
+  OP(AOP, MULT,		"*")						\
+  OP(AOP, DIV,		"/")						\
+  OP(AOP, MOD,		"%")						\
+  OP(AOP, AND,		"&")	/* bit ops */				\
+  OP(AOP, OR,		"|")						\
+  OP(AOP, XOR,		"^")						\
+  OP(AOP, RSHIFT,		">>")						\
+  OP(AOP, LSHIFT,		"<<")						\
 									\
-  OP(COMPL,		"~")						\
-  OP(AND_AND,		"&&")	/* logical */				\
-  OP(OR_OR,		"||")						\
-  OP(QUERY,		"?")						\
-  OP(COLON,		":")						\
-  OP(COMMA,		",")	/* grouping */				\
-  OP(OPEN_PAREN,	"(")						\
-  OP(CLOSE_PAREN,	")")						\
-  TK(EOF,		NONE)						\
-  OP(EQ_EQ,		"==")	/* compare */				\
-  OP(NOT_EQ,		"!=")						\
-  OP(GREATER_EQ,	">=")						\
-  OP(LESS_EQ,		"<=")						\
+  OP(BOP, COMPL,		"~")						\
+  OP(BOP, AND_AND,		"&&")	/* logical */				\
+  OP(BOP, OR_OR,		"||")						\
+  OP(AOP, QUERY,		"?")						\
+  OP(AOP, COLON,		":")						\
+  OP(GRP, COMMA,		",")	/* grouping */				\
+  OP(GRP, OPEN_PAREN,	"(")						\
+  OP(GRP, CLOSE_PAREN,	")")						\
+  TK(PAD, EOF,		NONE)						\
+  OP(BOP, EQ_EQ,		"==")	/* compare */				\
+  OP(BOP, NOT_EQ,		"!=")						\
+  OP(BOP, GREATER_EQ,	">=")						\
+  OP(BOP, LESS_EQ,		"<=")						\
 									\
   /* These two are unary + / - in preprocessor expressions.  */		\
-  OP(PLUS_EQ,		"+=")	/* math */				\
-  OP(MINUS_EQ,		"-=")						\
+  OP(AOP, PLUS_EQ,		"+=")	/* math */				\
+  OP(AOP, MINUS_EQ,		"-=")						\
 									\
-  OP(MULT_EQ,		"*=")						\
-  OP(DIV_EQ,		"/=")						\
-  OP(MOD_EQ,		"%=")						\
-  OP(AND_EQ,		"&=")	/* bit ops */				\
-  OP(OR_EQ,		"|=")						\
-  OP(XOR_EQ,		"^=")						\
-  OP(RSHIFT_EQ,		">>=")						\
-  OP(LSHIFT_EQ,		"<<=")						\
+  OP(AOP, MULT_EQ,		"*=")						\
+  OP(AOP, DIV_EQ,		"/=")						\
+  OP(AOP, MOD_EQ,		"%=")						\
+  OP(AOP, AND_EQ,		"&=")	/* bit ops */				\
+  OP(AOP, OR_EQ,		"|=")						\
+  OP(AOP, XOR_EQ,		"^=")						\
+  OP(AOP, RSHIFT_EQ,		">>=")						\
+  OP(AOP, LSHIFT_EQ,		"<<=")						\
   /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */		\
-  OP(HASH,		"#")	/* digraphs */				\
-  OP(PASTE,		"##")						\
-  OP(OPEN_SQUARE,	"[")						\
-  OP(CLOSE_SQUARE,	"]")						\
-  OP(OPEN_BRACE,	"{")						\
-  OP(CLOSE_BRACE,	"}")						\
+  OP(TRI, HASH,		"#")	/* digraphs */				\
+  OP(TRI, PASTE,		"##")						\
+  OP(BLK, OPEN_SQUARE,	"[")						\
+  OP(BLK, CLOSE_SQUARE,	"]")						\
+  OP(BLK, OPEN_BRACE,	"{")						\
+  OP(BLK, CLOSE_BRACE,	"}")						\
   /* The remainder of the punctuation.	Order is not significant.  */	\
-  OP(SEMICOLON,		";")	/* structure */				\
-  OP(ELLIPSIS,		"...")						\
-  OP(PLUS_PLUS,		"++")	/* increment */				\
-  OP(MINUS_MINUS,	"--")						\
-  OP(DEREF,		"->")	/* accessors */				\
-  OP(DOT,		".")						\
-  OP(SCOPE,		"::")						\
-  OP(DEREF_STAR,	"->*")						\
-  OP(DOT_STAR,		".*")						\
-  OP(ATSIGN,		"@")  /* used in Objective-C */			\
+  OP(GRP, SEMICOLON,		";")	/* structure */				\
+  OP(GRP, ELLIPSIS,		"...")						\
+  OP(AOP, PLUS_PLUS,		"++")	/* increment */				\
+  OP(AOP, MINUS_MINUS,	"--")						\
+  OP(GRP, DEREF,		"->")	/* accessors */				\
+  OP(GRP, DOT,		".")						\
+  OP(GRP, SCOPE,		"::")						\
+  OP(GRP, DEREF_STAR,	"->*")						\
+  OP(GRP, DOT_STAR,		".*")						\
+  OP(GRP, ATSIGN,		"@")  /* used in Objective-C */			\
 									\
-  TK(NAME,		IDENT)	 /* word */				\
-  TK(AT_NAME,		IDENT)	 /* @word - Objective-C */		\
-  TK(NUMBER,		LITERAL) /* 34_be+ta  */			\
+  TK(TOK, NAME,		IDENT)	 /* word */				\
+  TK(TOK, AT_NAME,		IDENT)	 /* @word - Objective-C */		\
+  TK(TOK, NUMBER,		LITERAL) /* 34_be+ta  */			\
 									\
-  TK(CHAR,		LITERAL) /* 'char' */				\
-  TK(WCHAR,		LITERAL) /* L'char' */				\
-  TK(OTHER,		LITERAL) /* stray punctuation */		\
+  TK(TOK, CHAR,		LITERAL) /* 'char' */				\
+  TK(TOK, WCHAR,		LITERAL) /* L'char' */				\
+  TK(TOK, OTHER,		LITERAL) /* stray punctuation */		\
 									\
-  TK(STRING,		LITERAL) /* "string" */				\
-  TK(WSTRING,		LITERAL) /* L"string" */			\
-  TK(OBJC_STRING,	LITERAL) /* @"string" - Objective-C */		\
-  TK(HEADER_NAME,	LITERAL) /* <stdio.h> in #include */		\
+  TK(STR, STRING,		LITERAL) /* "string" */				\
+  TK(STR, WSTRING,		LITERAL) /* L"string" */			\
+  TK(TOK, OBJC_STRING,	LITERAL) /* @"string" - Objective-C */		\
+  TK(TOK, HEADER_NAME,	LITERAL) /* <stdio.h> in #include */		\
 									\
-  TK(COMMENT,		LITERAL) /* Only if output comments.  */	\
+  TK(CMT, COMMENT,		LITERAL) /* Only if output comments.  */ \
 				 /* SPELL_LITERAL happens to DTRT.  */	\
-  TK(MACRO_ARG,		NONE)	 /* Macro argument.  */			\
-  TK(PRAGMA,		NONE)	 /* Only for deferred pragmas.  */	\
-  TK(PRAGMA_EOL,	NONE)	 /* End-of-line for deferred pragmas.  */ \
-  TK(PADDING,		NONE)	 /* Whitespace for -E.	*/
+  TK(CMT, MACRO_ARG,		NONE)	 /* Macro argument.  */			\
+  TK(CMT, PRAGMA,		NONE)	 /* Only for deferred pragmas.  */	\
+  TK(CMT, PRAGMA_EOL,	NONE)	 /* End-of-line for deferred pragmas.  */ \
+  TK(CMT, PARSEINFOSTACK,	NONE)	 /* push parseinfo token on path stack.  */ \
+  TK(PAD, PADDING,		NONE)	 /* Whitespace for -E.	*/              
 
-#define OP(e, s) CPP_ ## e,
-#define TK(e, s) CPP_ ## e,
+#define OP(sh, e, s) CPP_ ## e,
+#define TK(sh, e, s) CPP_ ## e,
 enum cpp_ttype
 {
   TTYPE_TABLE
@@ -175,6 +176,8 @@
 #define PURE_ZERO	(1 << 7) /* Single 0 digit, used by the C++ frontend,
 				    set in c-lex.c.  */
 
+#define CPP_MACRO_NEWLINE (1 << 8)
+
 /* Specify which field, if any, of the cpp_token union is used.  */
 
 enum cpp_token_fld_kind {
@@ -183,6 +186,7 @@
   CPP_TOKEN_FLD_STR,
   CPP_TOKEN_FLD_ARG_NO,
   CPP_TOKEN_FLD_PRAGMA,
+  CPP_TOKEN_FLD_PARSEINFOSTACK,
   CPP_TOKEN_FLD_NONE
 };
 
@@ -192,7 +196,7 @@
 {
   source_location src_loc;	/* Location of first char of token.  */
   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */
-  unsigned char flags;		/* flags - see above */
+  unsigned int flags;		/* flags - see above */
 
   union cpp_token_u
   {
@@ -213,9 +217,15 @@
     /* Argument no. for a CPP_MACRO_ARG.  */
     unsigned int GTY ((tag ("CPP_TOKEN_FLD_ARG_NO"))) arg_no;
 
+    /* stack item for a CPP_PARSEINFOSTACK.  */
+    unsigned int GTY ((tag ("CPP_TOKEN_FLD_PARSEINFOSTACK"))) parseinfostack;
+
     /* Caller-supplied identifier for a CPP_PRAGMA.  */
     unsigned int GTY ((tag ("CPP_TOKEN_FLD_PRAGMA"))) pragma;
   } GTY ((desc ("cpp_token_val_index (&%1)"))) val;
+
+  int tokid;
+  struct cpp_macro *macro;
 };
 
 /* Say which field is in use.  */
@@ -282,6 +292,9 @@
      macro expansion.  */
   unsigned char discard_comments_in_macro_exp;
 
+  /* Nonzero means to retain spaces in preprocessing output.  */
+  unsigned char preserve_spaces;
+
   /* Nonzero means process the ISO trigraph sequences.  */
   unsigned char trigraphs;
 
@@ -377,6 +390,9 @@
      bother trying to do macro expansion and whatnot.  */
   unsigned char preprocessed;
 
+  /* Nonzero means we're inclding newlines of macro definition.  */
+  unsigned char fpreprocessnewline;
+    
   /* Print column number in error messages.  */
   unsigned char show_column;
 
@@ -451,8 +467,34 @@
 typedef const char *(*missing_header_cb)(cpp_reader *, const char *header, cpp_dir **);
 
 /* Call backs to cpplib client.  */
+struct cpp_parse_info_callbacks
+{
+    void (*gen_dep_info_macro) (const struct cpp_macro *);
+
+    void (*gen_parse_info_token) (const cpp_token *);
+    void (*gen_parse_info_header) (int, source_location,int *, int);
+    void (*gen_parse_info_header_direct) (int, source_location, int *, int, int);
+    void (*gen_parse_info_path_direct) (int *, int, int, int, int);
+    void (*gen_parse_info_char)(const char*);
+    void (*gen_parse_info_write)(const char*, int );
+    void (*gen_parse_info_loc)(source_location);
+    void (*gen_parse_info_loc_line)(source_location);
+    void (*gen_parse_info_printf)(const char *fmt, ...);
+    void (*gen_parse_info_updateloc)(struct cpp_parse_info_callbacks *cb, source_location src_loc, int);
+	
+
+    int flag_gen_dep_info;
+    int flag_gen_parse_info;
+    int *path;
+    int pathcnt;
+    int src_line;
+};
+
+/* Call backs to cpplib client.  */
 struct cpp_callbacks
 {
+    struct cpp_parse_info_callbacks parse_info_cb;
+
   /* Called when a new line of preprocessed output is started.  */
   void (*line_change) (cpp_reader *, const cpp_token *, int);
 
@@ -672,6 +714,7 @@
 extern unsigned char *cpp_token_as_text (cpp_reader *, const cpp_token *);
 extern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,
 				       unsigned char *, bool);
+extern char *cpp_output_token_buffer (const cpp_token *token);
 extern void cpp_register_pragma (cpp_reader *, const char *, const char *,
 				 void (*) (cpp_reader *), bool);
 extern void cpp_register_deferred_pragma (cpp_reader *, const char *,
diff -Naurb gcc-4.2.1.ori/libcpp/include/cpplib.h.rej gcc-4.2.1/libcpp/include/cpplib.h.rej
--- gcc-4.2.1.ori/libcpp/include/cpplib.h.rej	1970-01-01 00:00:00 +0000
+++ gcc-4.2.1/libcpp/include/cpplib.h.rej	2014-03-13 18:59:11 +0000
@@ -0,0 +1,18 @@
+***************
+*** 216,221 ****
+      /* Caller-supplied identifier for a CPP_PRAGMA.  */
+      unsigned int GTY ((tag ("CPP_TOKEN_FLD_PRAGMA"))) pragma;
+    } GTY ((desc ("cpp_token_val_index (&%1)"))) val;
+  };
+  
+  /* Say which field is in use.  */
+--- 216,224 ----
+      /* Caller-supplied identifier for a CPP_PRAGMA.  */
+      unsigned int GTY ((tag ("CPP_TOKEN_FLD_PRAGMA"))) pragma;
+    } GTY ((desc ("cpp_token_val_index (&%1)"))) val;
++ 
++   int tokid;
++   
+  };
+  
+  /* Say which field is in use.  */
diff -Naurb gcc-4.2.1.ori/libcpp/include/line-map.h gcc-4.2.1/libcpp/include/line-map.h
--- gcc-4.2.1.ori/libcpp/include/line-map.h	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/include/line-map.h	2014-03-13 18:59:11 +0000
@@ -58,6 +58,7 @@
   unsigned char sysp;
   /* Number of the low-order source_location bits used for a column number.  */
   unsigned int column_bits : 8;
+  int mapid;
 };
 
 /* A set of chronological line_map structures.  */
diff -Naurb gcc-4.2.1.ori/libcpp/init.c gcc-4.2.1/libcpp/init.c
--- gcc-4.2.1.ori/libcpp/init.c	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/init.c	2014-03-13 18:59:11 +0000
@@ -149,6 +149,7 @@
   CPP_OPTION (pfile, warn_multichar) = 1;
   CPP_OPTION (pfile, discard_comments) = 1;
   CPP_OPTION (pfile, discard_comments_in_macro_exp) = 1;
+  CPP_OPTION (pfile, preserve_spaces) = 0;
   CPP_OPTION (pfile, show_column) = 1;
   CPP_OPTION (pfile, tabstop) = 8;
   CPP_OPTION (pfile, operator_names) = 1;
@@ -189,6 +190,7 @@
 
   /* Initialize lexer state.  */
   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);
+  pfile->state.save_spaces = CPP_OPTION (pfile, preserve_spaces);
 
   /* Set up static tokens.  */
   pfile->avoid_paste.type = CPP_PADDING;
diff -Naurb gcc-4.2.1.ori/libcpp/internal.h gcc-4.2.1/libcpp/internal.h
--- gcc-4.2.1.ori/libcpp/internal.h	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/internal.h	2014-03-13 18:59:11 +0000
@@ -37,6 +37,9 @@
 typedef int iconv_t;  /* dummy */
 #endif
 
+extern int tokid;
+extern int replaceid;
+
 struct directive;		/* Deliberately incomplete.  */
 struct pending_option;
 struct op;
@@ -90,9 +93,11 @@
 #define CPP_ALIGN2(size, align) (((size) + ((align) - 1)) & ~((align) - 1))
 #define CPP_ALIGN(size) CPP_ALIGN2 (size, DEFAULT_ALIGNMENT)
 
-#define _cpp_mark_macro_used(NODE) do {					\
-  if ((NODE)->type == NT_MACRO && !((NODE)->flags & NODE_BUILTIN))	\
-    (NODE)->value.macro->used = 1; } while (0)
+#define _cpp_mark_macro_used(pfile,NODE) do {				\
+		if ((NODE)->type == NT_MACRO && !((NODE)->flags & NODE_BUILTIN)) { \
+			(NODE)->value.macro->used = 1;			\
+			directory_dep_push(pfile, (NODE)->value.macro); } \
+	} while (0)
 
 /* A generic memory buffer, and operations on it.  */
 typedef struct _cpp_buff _cpp_buff;
@@ -102,6 +107,8 @@
   unsigned char *base, *cur, *limit;
 };
 
+extern void directory_dep_push(cpp_reader *pfile, cpp_macro *m);
+extern void add_cpp_all_macros(cpp_macro *macro);
 extern _cpp_buff *_cpp_get_buff (cpp_reader *, size_t);
 extern void _cpp_release_buff (cpp_reader *, _cpp_buff *);
 extern void _cpp_extend_buff (cpp_reader *, _cpp_buff **, size_t);
@@ -175,6 +182,8 @@
 
 struct lexer_state
 {
+	struct cpp_macro *dep;
+	
   /* Nonzero if first token on line is CPP_HASH.  */
   unsigned char in_directive;
 
@@ -185,6 +194,7 @@
 
   /* True if we are skipping a failed conditional group.  */
   unsigned char skipping;
+  unsigned char skipping_old;
 
   /* Nonzero if in a directive that takes angle-bracketed headers.  */
   unsigned char angled_headers;
@@ -196,6 +206,9 @@
      all directives apart from #define.  */
   unsigned char save_comments;
 
+  /* Nonzero to save spaces.  */
+  unsigned char save_spaces;
+
   /* Nonzero if lexing __VA_ARGS__ is valid.  */
   unsigned char va_args_ok;
 
@@ -208,6 +221,9 @@
   /* Nonzero when parsing arguments to a function-like macro.  */
   unsigned char parsing_args;
 
+  /* depth of the replacement stack, recursive through expand_args().  */
+  unsigned char replace_args;
+
   /* Nonzero if prevent_expansion is true only because output is
      being discarded.  */
   unsigned char discarding_output;
@@ -243,6 +259,19 @@
   unsigned int type;
 };
 
+/* Stack of conditionals currently in progress
+   (including both successful and failing conditionals).  */
+struct if_stack
+{
+  struct if_stack *next;
+  unsigned int line;		/* Line where condition started.  */
+  const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */
+  bool skip_elses;		/* Can future #else / #elif be skipped?  */
+  bool was_skipping;		/* If were skipping on entry.  */
+  int type;			/* Most recent conditional for diagnostics.  */
+  struct cpp_macro *depend;
+};
+
 /* Represents the contents of a file cpplib has read in.  */
 struct cpp_buffer
 {
@@ -255,6 +284,7 @@
 
   _cpp_line_note *notes;           /* Array of notes.  */
   unsigned int cur_note;           /* Next note to process.  */
+  unsigned int cur_mnote;          /* Next note to process.  */
   unsigned int notes_used;         /* Number of notes.  */
   unsigned int notes_cap;          /* Size of allocated array.  */
 
@@ -372,6 +402,8 @@
   cpp_token *cur_token;
   tokenrun base_run, *cur_run;
   unsigned int lookaheads;
+  source_location __line__;
+  int __line__cnt;
 
   /* Nonzero prevents the lexer from re-using the token runs.  */
   unsigned int keep_tokens;
@@ -448,6 +480,16 @@
   /* A saved list of the defined macros, for dependency checking
      of precompiled headers.  */
   struct cpp_savedstate *savedstate;
+
+
+    int *replacestack;
+    int replacestackcnt;
+
+    int opentokid;
+    int closetokid;
+    source_location opentoksrc_loc;
+    source_location closetoksrc_loc;
+    cpp_macro *curmacro;
 };
 
 /* Character classes.  Based on the more primitive macros in safe-ctype.h.
@@ -495,6 +537,7 @@
 /* In macro.c */
 extern void _cpp_free_definition (cpp_hashnode *);
 extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);
+extern void _cpp_macro_dep_push (cpp_reader *, cpp_macro *, cpp_macro *);
 extern void _cpp_pop_context (cpp_reader *);
 extern void _cpp_push_text_context (cpp_reader *, cpp_hashnode *,
 				    const unsigned char *, size_t);
@@ -533,9 +576,12 @@
 /* In expr.c */
 extern bool _cpp_parse_expr (cpp_reader *);
 extern struct op *_cpp_expand_op_stack (cpp_reader *);
+extern void parse_info_directive_token (cpp_reader *pfile, cpp_token *token);
 
 /* In lex.c */
 extern void _cpp_process_line_notes (cpp_reader *, int);
+extern void _cpp_process_mline_notes (cpp_reader *);
+
 extern void _cpp_clean_line (cpp_reader *);
 extern bool _cpp_get_fresh_line (cpp_reader *);
 extern bool _cpp_skip_block_comment (cpp_reader *);
diff -Naurb gcc-4.2.1.ori/libcpp/lex.c gcc-4.2.1/libcpp/lex.c
--- gcc-4.2.1.ori/libcpp/lex.c	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/lex.c	2014-03-13 18:59:11 +0000
@@ -38,11 +38,13 @@
   const unsigned char *name;
 };
 
+int tokid = 1;
+
 static const unsigned char *const digraph_spellings[] =
 { U"%:", U"%:%:", U"<:", U":>", U"<%", U"%>" };
 
-#define OP(e, s) { SPELL_OPERATOR, U s  },
-#define TK(e, s) { SPELL_ ## s,    U #e },
+#define OP(sh, e, s) { SPELL_OPERATOR, U s  },
+#define TK(sh, e, s) { SPELL_ ## s,    U #e },
 static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };
 #undef OP
 #undef TK
@@ -52,7 +54,7 @@
 
 static void add_line_note (cpp_buffer *, const uchar *, unsigned int);
 static int skip_line_comment (cpp_reader *);
-static void skip_whitespace (cpp_reader *, cppchar_t);
+static void skip_whitespace (cpp_reader *, cppchar_t, cpp_token *);
 static void lex_string (cpp_reader *, cpp_token *, const uchar *);
 static void save_comment (cpp_reader *, cpp_token *, const uchar *, cppchar_t);
 static void create_literal (cpp_reader *, cpp_token *, const uchar *,
@@ -82,6 +84,8 @@
 static void
 add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type)
 {
+    
+    
   if (buffer->notes_used == buffer->notes_cap)
     {
       buffer->notes_cap = buffer->notes_cap * 2 + 200;
@@ -104,7 +108,7 @@
   uchar c, *d, *p;
 
   buffer = pfile->buffer;
-  buffer->cur_note = buffer->notes_used = 0;
+  buffer->cur_mnote = buffer->cur_note = buffer->notes_used = 0;
   buffer->cur = buffer->line_base = buffer->next_line;
   buffer->need_line = false;
   s = buffer->next_line - 1;
@@ -142,6 +146,9 @@
 		 the slow path.  */
 	      add_line_note (buffer, p - 1, p != d ? ' ' : '\\');
 	      d = p - 2;
+              if (pfile->state.save_spaces && !pfile->state.in_directive) {
+                  *++d = 1;
+              }
 	      buffer->next_line = p - 1;
 	      break;
 	    }
@@ -185,6 +192,9 @@
 
 	      add_line_note (buffer, p - 1, p != d ? ' ': '\\');
 	      d = p - 2;
+              if (pfile->state.save_spaces && !pfile->state.in_directive) {
+                  *++d = 1;
+              }
 	      buffer->next_line = p - 1;
 	    }
 	  else if (c == '?' && s[1] == '?' && _cpp_trigraph_map[s[2]])
@@ -246,11 +256,54 @@
   return (*p == '\n' && p < note[1].pos);
 }
 
+/* void */
+/* _cpp_process_mline_notes (cpp_reader *pfile) */
+/* { */
+/*     cpp_buffer *buffer = pfile->buffer; */
+/*     cpp_macro *macro = 0; */
+    
+/*     if (pfile->cb.parse_info_cb.flag_gen_parse_info) { */
+	
+/* 	//for (;;) */
+/* 	while( buffer->notes_used  > buffer->cur_mnote) */
+/* 	    { */
+/* 		_cpp_line_note *note = &buffer->notes[buffer->cur_mnote]; */
+		
+/* 		if (note->pos > buffer->cur) */
+/* 		    break; */
+		
+/* 		buffer->cur_mnote++; */
+		
+/* 		if (note->type == '\\' || note->type == ' ') */
+/* 		    { */
+/* 			if (pfile->curmacro && note->type == '\\') { */
+/* 			    /\* register a \\ in the macro definition *\/ */
+/* 			    int idx = 0; macro = pfile->curmacro; */
+/* 			    if ((idx = macro->notecnt++)) { */
+/* 				macro->note = XRESIZEVEC(int,macro->note,macro->notecnt); */
+/* 			    } else { */
+/* 				macro->note = XNEWVEC(int,macro->notecnt); */
+/* 			    } */
+/* 			    macro->note[idx] = macro->count > 0 ? macro->count-1 : macro->count; */
+/* 			} */
+			
+/* 		    } */
+/* 		else if (_cpp_trigraph_map[note->type]) */
+/* 		    { */
+/* 		    } */
+/* 		else  */
+/* 		    break; */
+/* 	    } */
+/*     } */
+    
+/* } */
+
 /* Process the notes created by add_line_note as far as the current
    location.  */
 void
 _cpp_process_line_notes (cpp_reader *pfile, int in_comment)
 {
+    cpp_macro *macro = 0;
   cpp_buffer *buffer = pfile->buffer;
 
   for (;;)
@@ -266,6 +319,27 @@
 
       if (note->type == '\\' || note->type == ' ')
 	{
+	    if (pfile->cb.parse_info_cb.flag_gen_parse_info ||
+                CPP_OPTION (pfile, fpreprocessnewline)) {
+		if (pfile->curmacro && note->type == '\\') {
+		    /* register a \\ in the macro definition */
+		    int idx = 0; macro = pfile->curmacro;
+		    if ((idx = macro->notecnt++)) {
+			macro->note = XRESIZEVEC(int,macro->note,macro->notecnt);
+		    } else {
+			macro->note = XNEWVEC(int,macro->notecnt);
+		    }
+		    macro->note[idx] = macro->count > 0 ? macro->count-1 : macro->count;
+		}
+	    }
+	    
+	    
+	    /*
+	    if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+		pfile->cb.parse_info_cb.gen_parse_info_char("@(\\)\n");
+	    }
+	    */
+	    
 	  if (note->type == ' ' && !in_comment)
 	    cpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line_table->highest_line, col,
 				 "backslash and newline separated by space");
@@ -383,34 +457,58 @@
 
 /* Skips whitespace, saving the next non-whitespace character.  */
 static void
-skip_whitespace (cpp_reader *pfile, cppchar_t c)
+skip_whitespace (cpp_reader *pfile, cppchar_t c, cpp_token *token)
 {
+  cppchar_t _c = c;
   cpp_buffer *buffer = pfile->buffer;
+  const unsigned char *cur = buffer->cur;
   bool saw_NUL = false;
 
   do
     {
       /* Horizontal space always OK.  */
-      if (c == ' ' || c == '\t')
+      if (c == ' ' || c == '\t' )
 	;
+      else if ((((char)c) == 1 )) {
+          
+      }
       /* Just \f \v or \0 left.  */
       else if (c == '\0')
 	saw_NUL = true;
       else if (pfile->state.in_directive && CPP_PEDANTIC (pfile))
 	cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line_table->highest_line,
 			     CPP_BUF_COL (buffer),
-			     "%s in preprocessing directive",
+			     "%d: %s in preprocessing directive", c,
 			     c == '\f' ? "form feed" : "vertical tab");
 
       c = *buffer->cur++;
     }
   /* We only want non-vertical space, i.e. ' ' \t \f \v \0.  */
-  while (is_nvspace (c));
+  while (((pfile->state.save_spaces) && (1 == ((char)c))) || is_nvspace (c));
+
+  if (pfile->state.save_spaces) {
+      unsigned char *b;
+      unsigned int clen = (buffer->cur - cur) + 2, i;
+      b = _cpp_unaligned_alloc (pfile, clen);
+      token->type = CPP_COMMENT;
+      token->val.str.len = clen-2;
+      token->val.str.text = b;
+      b[0] = _c;
+      if (clen-2-1 > 0)
+          memcpy(b+1,cur,clen-2-1);
+      for(i = 0; i < clen-2; i++) {
+          if (((char)(b[i])) == 1) {
+              b[i] = '\n';
+          }
+      }
+      b[clen-2] = 0;
+  }
 
   if (saw_NUL)
     cpp_error (pfile, CPP_DL_WARNING, "null character(s) ignored");
 
   buffer->cur--;
+  
 }
 
 /* See if the characters of a number token are valid in a name (no
@@ -693,6 +791,8 @@
       buffer[clen - 2] = '*';
       buffer[clen - 1] = '/';
     }
+  
+  /*printf("Alloc:\"%s\"\n",buffer); */
 }
 
 /* Allocate COUNT tokens for RUN.  */
@@ -736,6 +836,8 @@
 
   result = pfile->cur_token++;
   result->src_loc = old->src_loc;
+  result->tokid = tokid++;
+    
   return result;
 }
 
@@ -858,6 +960,15 @@
     }							\
   while (0)
 
+cpp_token *_cpp_lex_direct_real (cpp_reader *pfile);
+cpp_token *
+_cpp_lex_direct (cpp_reader *pfile)
+{
+    cpp_token *tok = _cpp_lex_direct_real (pfile);
+    tok->tokid = tokid++;
+    return tok;
+}
+
 /* Lex a token into pfile->cur_token, which is also incremented, to
    get diagnostics pointing to the correct location.
 
@@ -870,7 +981,7 @@
    otherwise returns to the start of the token buffer if permissible.
    Returns the location of the lexed token.  */
 cpp_token *
-_cpp_lex_direct (cpp_reader *pfile)
+_cpp_lex_direct_real (cpp_reader *pfile)
 {
   cppchar_t c;
   cpp_buffer *buffer;
@@ -929,10 +1040,12 @@
 
   switch (c)
     {
-    case ' ': case '\t': case '\f': case '\v': case '\0':
+    case ' ': case '\t': case '\f': case '\v': case '\0': case 1:
       result->flags |= PREV_WHITE;
-      skip_whitespace (pfile, c);
+      skip_whitespace (pfile, c, result);
+      if (!pfile->state.save_spaces)
       goto skipped_white;
+      break;
 
     case '\n':
       if (buffer->cur < buffer->rlimit)
@@ -1031,7 +1144,7 @@
 	  break;
 	}
 
-      if (!pfile->state.save_comments)
+      if ((!pfile->state.save_comments) && (pfile->state.in_directive || !pfile->cb.parse_info_cb.flag_gen_parse_info))
 	{
 	  result->flags |= PREV_WHITE;
 	  goto update_tokens_line;
@@ -1214,6 +1327,8 @@
       break;
     }
 
+  /*_cpp_process_mline_notes(pfile);*/
+  
   return result;
 }
 
@@ -1415,6 +1530,88 @@
     }
 }
 
+/* Writes the spelling of token to buf, without any preceding space.
+   Separated from cpp_spell_token for efficiency - to avoid stdio
+   double-buffering.  */
+char *
+cpp_output_token_buffer (const cpp_token *token)
+{
+    int j = 0; char *buf = 0;
+    for (j = 0; j < 2; j++) {
+        int buflen = 0; 
+        switch (TOKEN_SPELL (token))
+            {
+            case SPELL_OPERATOR:
+                {
+                    const unsigned char *spelling;
+                    int c;
+                    
+                    if (token->flags & DIGRAPH)
+                        spelling
+                            = digraph_spellings[(int) token->type - (int) CPP_FIRST_DIGRAPH];
+                    else if (token->flags & NAMED_OP)
+                        goto spell_ident;
+                    else
+                        spelling = TOKEN_NAME (token);
+                    
+                    c = *spelling;
+                    do {
+                        if (buf) {
+                            buf[buflen] = c;
+                        }
+                        buflen++;
+                    } while ((c = *++spelling) != '\0');
+                }
+                break;
+                
+            spell_ident:
+            case SPELL_IDENT:
+                {
+                    size_t i;
+                    const unsigned char * name = NODE_NAME (token->val.node);
+                    
+                    for (i = 0; i < NODE_LEN (token->val.node); i++)
+                        if (name[i] & ~0x7F)
+                            {
+                                unsigned char buffer[10];
+                                i += utf8_to_ucn (buffer, name + i) - 1;
+                                if (buf) {
+                                    memcpy(&buf[buflen],buffer,10);
+                                }
+                                buflen+=10;
+                            }
+                        else {
+                            if ( buf) {
+                                buf[buflen] = NODE_NAME (token->val.node)[i];
+                            }
+                            
+                            buflen++;
+                        }
+                    
+                }
+                break;
+                
+            case SPELL_LITERAL:
+                if(buf) {
+                    memcpy(&buf[buflen],token->val.str.text,token->val.str.len);
+                }	
+                buflen += token->val.str.len;
+                break;
+                
+            case SPELL_NONE:
+                /* An error, most probably.  */
+                break;
+            }
+        if (buf) {
+            buf[buflen] = 0;
+        } else {
+            buf = XNEWVEC (char, buflen+2);
+        }
+    }
+    return buf;
+}
+
+
 /* Compare two tokens.  */
 int
 _cpp_equiv_tokens (const cpp_token *a, const cpp_token *b)
diff -Naurb gcc-4.2.1.ori/libcpp/line-map.c gcc-4.2.1/libcpp/line-map.c
--- gcc-4.2.1.ori/libcpp/line-map.c	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/line-map.c	2014-03-13 18:59:11 +0000
@@ -83,12 +83,12 @@
    function.  A call to this function can relocate the previous set of
    A call to this function can relocate the previous set of
    maps, so any stored line_map pointers should not be used.  */
-
+int mapid = 1;
 const struct line_map *
 linemap_add (struct line_maps *set, enum lc_reason reason,
 	     unsigned int sysp, const char *to_file, unsigned int to_line)
 {
-  struct line_map *map;
+  struct line_map *map; struct line_map *from = 0;
   source_location start_location = set->highest_location + 1;
 
   if (set->used && start_location < set->maps[set->used - 1].start_location)
@@ -111,7 +111,6 @@
     reason = LC_ENTER;
   else if (reason == LC_LEAVE)
     {
-      struct line_map *from;
       bool error;
 
       if (MAIN_FILE_P (map - 1))
@@ -159,6 +158,7 @@
 
   if (reason == LC_ENTER)
     {
+      map->mapid = mapid++;
       map->included_from = set->depth == 0 ? -1 : (int) (set->used - 2);
       set->depth++;
       if (set->trace_includes)
@@ -168,6 +168,7 @@
     map->included_from = map[-1].included_from;
   else if (reason == LC_LEAVE)
     {
+      map->mapid = from->mapid;
       set->depth--;
       map->included_from = INCLUDED_FROM (set, map - 1)->included_from;
     }
@@ -296,6 +297,25 @@
   return &set->maps[mn];
 }
 
+/* Given a location_t look up the coresponding source_location  */
+
+/* const source_location */
+/* linemap_lookup_location (struct line_maps *set, char *fn, int line) */
+/* { */
+/*     unsigned int i, mx; */
+/*   const struct line_map *cached; */
+/*   source_location src_loc; */
+
+/*   mn = set->cache; */
+/*   mx = set->used; */
+  
+/*   for(i = 0; i < mx; i++) { */
+/*       cached = &set->maps[i]; */
+      
+/*   } */
+/*   return src_loc; */
+/* } */
+
 /* Print the file names and line numbers of the #include commands
    which led to the map MAP, if any, to stderr.  Nothing is output if
    the most recently listed stack is the same as the current one.  */
diff -Naurb gcc-4.2.1.ori/libcpp/macro.c gcc-4.2.1/libcpp/macro.c
--- gcc-4.2.1.ori/libcpp/macro.c	2014-03-13 18:58:55 +0000
+++ gcc-4.2.1/libcpp/macro.c	2014-03-13 18:59:11 +0000
@@ -38,9 +38,18 @@
   unsigned int expanded_count;	/* # of tokens in expanded argument.  */
 };
 
+int replaceid = 1;
+static int acc_stack_sz = 0;
+static int acc_stack_cnt = -1;
+static cpp_token **acc_stack = 0;
+
+static int 
+handle_parseinfo(cpp_reader *pfile,const cpp_token *token);
+
 /* Macro expansion.  */
+static cpp_token *create_parseinfo_token (cpp_reader *, cpp_macro *);
 
-static int enter_macro_context (cpp_reader *, cpp_hashnode *);
+static int enter_macro_context (cpp_reader *, cpp_hashnode *,cpp_token *);
 static int builtin_macro (cpp_reader *, cpp_hashnode *);
 static void push_ptoken_context (cpp_reader *, cpp_hashnode *, _cpp_buff *,
 				 const cpp_token **, unsigned int);
@@ -52,8 +61,8 @@
 static const cpp_token *stringify_arg (cpp_reader *, macro_arg *);
 static void paste_all_tokens (cpp_reader *, const cpp_token *);
 static bool paste_tokens (cpp_reader *, const cpp_token **, const cpp_token *);
-static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,
-			  macro_arg *);
+ void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,
+			  macro_arg *,const cpp_token *);
 static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *);
 static bool create_iso_definition (cpp_reader *, cpp_macro *);
 
@@ -199,7 +208,8 @@
       if (CPP_OPTION (pfile, traditional))
 	number = pfile->line_table->highest_line;
       else
-	number = pfile->cur_token[-1].src_loc;
+          number = pfile->__line__; /*pfile->cur_token[-1].src_loc;*/
+      /*fprintf(stderr,"%d:%d\n",pfile->__line__cnt,pfile->__line__);*/
       number = SOURCE_LINE (map, number);
       break;
 
@@ -432,9 +442,10 @@
 {
   unsigned char *buf, *end, *lhsend;
   const cpp_token *lhs;
-  unsigned int len;
+  unsigned int len; int lhstokid;
 
   lhs = *plhs;
+  lhstokid = lhs->tokid;
   len = cpp_token_len (lhs) + cpp_token_len (rhs) + 1;
   buf = (unsigned char *) alloca (len);
   end = lhsend = cpp_spell_token (pfile, lhs, buf, false);
@@ -454,6 +465,16 @@
   /* Set pfile->cur_token as required by _cpp_lex_direct.  */
   pfile->cur_token = _cpp_temp_token (pfile);
   *plhs = _cpp_lex_direct (pfile);
+  
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      char b[96];
+      pfile->cb.parse_info_cb.gen_parse_info_header(lhs->tokid,lhs->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+      pfile->cb.parse_info_cb.gen_parse_info_char("(");
+      sprintf(b,"%d##%d => %d",lhstokid,rhs->tokid,(*plhs) ? (*plhs)->tokid : -1);
+      pfile->cb.parse_info_cb.gen_parse_info_char(b);
+      pfile->cb.parse_info_cb.gen_parse_info_char(")\n");
+  }
+  
   if (pfile->buffer->cur != pfile->buffer->rlimit)
     {
       _cpp_pop_buffer (pfile);
@@ -482,7 +503,7 @@
 static void
 paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)
 {
-  const cpp_token *rhs;
+  const cpp_token *rhs; cpp_token **ptok = 0; int ptokcnt = 0;
   cpp_context *context = pfile->context;
 
   do
@@ -492,11 +513,34 @@
 	 object-like macro, or a function-like macro with arguments
 	 inserted.  In either case, the constraints to #define
 	 guarantee we have at least one more token.  */
+
+        /*do {*/
       if (context->direct_p)
 	rhs = FIRST (context).token++;
       else
 	rhs = *FIRST (context).ptoken++;
 
+            /*} while((pfile->state.save_spaces &&
+                 rhs->type == CPP_COMMENT &&
+                 FIRST (context).token != LAST (context).token));
+        
+        if ((pfile->state.save_spaces &&
+             rhs->type == CPP_COMMENT &&
+             FIRST (context).token == LAST (context).token)) {
+             break;
+             }*/
+
+      if ((pfile->cb.parse_info_cb.flag_gen_parse_info &&
+          rhs->type == CPP_PARSEINFOSTACK)) {
+          if(ptokcnt++) {
+              ptok = XRESIZEVEC(cpp_token *,ptok,ptokcnt+1);
+          } else {
+              ptok = XNEWVEC(cpp_token *,ptokcnt+1);
+          }
+          ptok[ptokcnt-1] = (cpp_token *)rhs;
+          continue;
+      }
+          
       if (rhs->type == CPP_PADDING)
 	abort ();
 
@@ -505,8 +549,14 @@
     }
   while (rhs->flags & PASTE_LEFT);
 
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+      ptok) {
+      ptok[ptokcnt] = (cpp_token *)lhs;
+      push_ptoken_context (pfile, NULL, (_cpp_buff *)ptok, (const cpp_token **)ptok, ptokcnt+1);
+  } else {
   /* Put the resulting token in its own context.  */
   _cpp_push_token_context (pfile, NULL, lhs, 1);
+  }
 }
 
 /* Returns TRUE if the number of arguments ARGC supplied in an
@@ -564,6 +614,8 @@
   macro_arg *args, *arg;
   const cpp_token *token;
   unsigned int argc;
+  unsigned int old_save = pfile->state.save_spaces;
+  pfile->state.save_spaces = 0;
 
   macro = node->value.macro;
   if (macro->paramc)
@@ -646,6 +698,10 @@
 	}
     }
   while (token->type != CPP_CLOSE_PAREN && token->type != CPP_EOF);
+  pfile->closetokid = token->tokid;
+  pfile->closetoksrc_loc = token->src_loc;
+
+  pfile->state.save_spaces = old_save;
 
   if (token->type == CPP_EOF)
     {
@@ -695,6 +751,7 @@
 {
   const cpp_token *token, *padding = NULL;
 
+  acc_stack_cnt = 0;
   for (;;)
     {
       token = cpp_get_token (pfile);
@@ -707,6 +764,10 @@
 
   if (token->type == CPP_OPEN_PAREN)
     {
+	acc_stack_cnt = -1;
+      pfile->opentokid = token->tokid;
+      pfile->opentoksrc_loc = token->src_loc;
+
       pfile->state.parsing_args = 2;
       return collect_args (pfile, node);
     }
@@ -721,17 +782,37 @@
       _cpp_backup_tokens (pfile, 1);
       if (padding)
 	_cpp_push_token_context (pfile, NULL, padding, 1);
+
+      /* revert the parseinfo stack manipulations */
+      if (acc_stack_cnt>0) {
+	  int i, len = acc_stack_cnt;
+	  acc_stack_cnt = -1;
+	  for (i = len-1; i >= 0; i--) {
+	      int ori = acc_stack[i]->val.parseinfostack;
+	      if (acc_stack[i]->type != CPP_PARSEINFOSTACK) {
+		  abort();
+	      }
+	      acc_stack[i]->val.parseinfostack = -ori;
+	      handle_parseinfo(pfile,acc_stack[i]);
+	      acc_stack[i]->val.parseinfostack = ori;
+	  }
+	  push_ptoken_context (pfile, NULL, NULL, (const cpp_token **)acc_stack, len);
     }
+    }
+	acc_stack_cnt = -1;
 
   return NULL;
 }
 
+
+
+
 /* Push the context of a macro with hash entry NODE onto the context
    stack.  If we can successfully expand the macro, we push a context
    containing its yet-to-be-rescanned replacement list and return one.
    Otherwise, we don't push a context and return zero.  */
 static int
-enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)
+enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,cpp_token *mresult)
 {
   /* The presence of a macro invalidates a file's controlling macro.  */
   pfile->mi_valid = false;
@@ -741,8 +822,19 @@
   /* Handle standard macros.  */
   if (! (node->flags & NODE_BUILTIN))
     {
+	    int i;
+	    
       cpp_macro *macro = node->value.macro;
 
+      if (pfile->cb.parse_info_cb.flag_gen_dep_info ) {
+	      i = 0;
+	      directory_dep_push(pfile, macro);
+	      
+	      if (pfile->cb.parse_info_cb.gen_dep_info_macro) 
+		      pfile->cb.parse_info_cb.gen_dep_info_macro(macro);
+      }
+      
+      
       if (macro->fun_like)
 	{
 	  _cpp_buff *buff;
@@ -762,11 +854,16 @@
  "function-like macro \"%s\" must be used with arguments in traditional C",
 			   NODE_NAME (node));
 
+              pfile->__line__cnt--;
 	      return 0;
 	    }
 
-	  if (macro->paramc > 0)
-	    replace_args (pfile, node, macro, (macro_arg *) buff->base);
+	  if (macro->paramc > 0) {
+	      pfile->state.replace_args++;
+	      replace_args (pfile, node, macro, (macro_arg *) buff->base, mresult);
+	      pfile->state.replace_args--;
+	  }
+	  
 	  _cpp_release_buff (pfile, buff);
 	}
 
@@ -775,8 +872,81 @@
 
       macro->used = 1;
 
-      if (macro->paramc == 0)
-	_cpp_push_token_context (pfile, node, macro->exp.tokens, macro->count);
+      if (macro->paramc == 0) {
+        cpp_token *token = macro->exp.tokens;
+        int count = macro->count;
+        if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+            char *mdef; _cpp_buff *buff; cpp_token *ctok, *ptok1, *ptok2; int i, oreplaceid = replaceid++;
+	    ptok1  = create_parseinfo_token(pfile, macro);
+	    ptok1->val.parseinfostack = oreplaceid;
+	    ptok2  = create_parseinfo_token(pfile, macro);
+	    ptok2->val.parseinfostack = -oreplaceid;
+	    buff = _cpp_get_buff (pfile, (count + 2)* sizeof (cpp_token));
+	    ctok = (cpp_token *) buff->base;
+	    memcpy(ctok+1,token,(count ) * sizeof (cpp_token));
+	    ctok[0] = *ptok1;
+	    ctok[count+1] = *ptok2;
+
+	    if (pfile->cb.parse_info_cb.pathcnt == 0 && pfile->state.replace_args == 0) {
+		/* 414:=>:TOK      [ g */
+		    pfile->cb.parse_info_cb.gen_parse_info_header(mresult->tokid,/*pfile->line_table->highest_line*/mresult->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+		pfile->cb.parse_info_cb.gen_parse_info_printf("=>%s:",pfile->state.in_directive ? "#" : "");
+		pfile->cb.parse_info_cb.gen_parse_info_token(mresult);
+		pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+	    }
+	    
+	    mdef = (char *)cpp_macro_definition (pfile, node); 
+
+	    /*	<=381   (2.3)   #NAME          [b]:test.c@4:@#define b(b) b + 1  */
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",mresult->tokid);
+	    pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[");
+	    pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("](@%d)#",macro->macroid);
+            pfile->cb.parse_info_cb.gen_parse_info_loc(macro->line);
+	    pfile->cb.parse_info_cb.gen_parse_info_printf("#%s\n",mdef);
+	    
+	    for (i = 0; i < count;i++) {
+		/* 398     [1]     	    |PLUS        [+ */
+		pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",token[i].tokid);
+		pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+		pfile->cb.parse_info_cb.gen_parse_info_char("\t\t");
+		pfile->cb.parse_info_cb.gen_parse_info_char("|\t");
+		pfile->cb.parse_info_cb.gen_parse_info_token(&token[i]);
+
+		{
+		    /* insert a special sequence for \\ */
+		    int j = 0; 
+		    for (j = 0; j < macro->notecnt; j++) {
+			if (macro->note[j] == (int)i) {
+			    pfile->cb.parse_info_cb.gen_parse_info_char("@@\\@@");
+			}
+		    }
+		}
+		
+		pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+	    }
+          
+	    token = ctok;
+	    count += 2;
+        }
+        if (CPP_OPTION (pfile, fpreprocessnewline)) {
+            int i = 0;
+            /* mark \\ for preprocess output */
+	    for (i = 0; i < count;i++) {
+                int j = 0;
+                for (j = 0; j < macro->notecnt; j++) {
+                    if (macro->note[j] == (int)i) {
+                        token[i].flags |= CPP_MACRO_NEWLINE;
+                    }
+                }
+            }
+        }
+        
+	_cpp_push_token_context (pfile, node, token, count);
+      }
+
+      /*mresult->tokid = tokid++;*/
 
       return 1;
     }
@@ -785,18 +955,153 @@
   return builtin_macro (pfile, node);
 }
 
+static cpp_token *
+create_parseinfo_token (cpp_reader *pfile, cpp_macro *macro) {
+    
+    cpp_token *token = _cpp_temp_token (pfile);
+    token->flags = 0;
+    token->type = CPP_PARSEINFOSTACK;
+    token->macro = macro;    
+    return token;
+}
+
+
+int macro_stack_size = 0;
+cpp_macro **macro_stack = 0;
+
+static int 
+handle_parseinfo(cpp_reader *pfile,const cpp_token *token) {
+	int id, i; cpp_macro *macro;
+    if (token->type != CPP_PARSEINFOSTACK)
+        return 0;
+
+    /* record stack manipulations for later restore, in funlike_invocation_p() */
+    if (acc_stack_cnt != -1) {
+	if ((++acc_stack_cnt) >= acc_stack_sz) {
+	    acc_stack_sz = acc_stack_cnt;
+	    if (acc_stack) {
+		acc_stack = XRESIZEVEC(cpp_token *,acc_stack,acc_stack_sz);
+	    } else {
+		acc_stack = XNEWVEC(cpp_token *,acc_stack_sz);
+	    }
+	}
+	acc_stack[acc_stack_cnt-1] = (cpp_token *)token;
+    }
+    
+    if ((id = token->val.parseinfostack) < 0) {
+        if ((!pfile->cb.parse_info_cb.path) ||
+            pfile->cb.parse_info_cb.path[pfile->cb.parse_info_cb.pathcnt-1] != -id) {
+            cpp_error (pfile, CPP_DL_ERROR, "internal error: expecting to pop %d",id);
+            abort();
+        }
+        pfile->cb.parse_info_cb.pathcnt--;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info ) 
+		macro_stack_size--;
+    } else {
+        if (pfile->cb.parse_info_cb.path) {
+            pfile->cb.parse_info_cb.path = XRESIZEVEC(int,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt+1);
+        } else {
+            pfile->cb.parse_info_cb.path = XNEWVEC(int,pfile->cb.parse_info_cb.pathcnt+1);
+        }
+        pfile->cb.parse_info_cb.path[pfile->cb.parse_info_cb.pathcnt] = id;
+        pfile->cb.parse_info_cb.pathcnt++;
+
+	macro = token->macro;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info ) {
+		i = 0;
+		/* fprintf(stderr,"Macro stack: ["); */
+/* 		for(i = 0; i < macro_stack_size; i++) { */
+/* 			fprintf(stderr," %d",macro_stack[i]->macroid); */
+/* 		} */
+/* 		fprintf(stderr,"]\n"); */
+		
+		if (macro_stack_size++) {
+			macro_stack = (struct cpp_macro **) xrealloc(macro_stack,macro_stack_size*sizeof(void*));
+			_cpp_macro_dep_push(pfile, macro_stack[macro_stack_size-2], macro); 
+		} else {
+			macro_stack = (struct cpp_macro **) xmalloc(macro_stack_size*sizeof(void*));
+		}
+		macro_stack[macro_stack_size-1] = macro;
+	}
+	
+    }
+    return 1;
+}
+    
 /* Replace the parameters in a function-like macro of NODE with the
    actual ARGS, and place the result in a newly pushed token context.
    Expand each argument before replacing, unless it is operated upon
    by the # or ## operators.  */
-static void
-replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg *args)
+void
+replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg *args, const cpp_token *mresult)
 {
-  unsigned int i, total;
+    unsigned int i, j = 0, total, oreplaceid = replaceid++, mpos = 0;
   const cpp_token *src, *limit;
-  const cpp_token **dest, **first;
-  macro_arg *arg;
+  cpp_token *ptok;
+  const cpp_token **dest, **first, **cfirst, **firstdest;
+  macro_arg *arg = 0;
   _cpp_buff *buff;
+  /*const unsigned char *mdef;*/
+  
+  
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      char *mdef;  
+      if (pfile->cb.parse_info_cb.pathcnt == 0 && pfile->state.replace_args == 1) {
+          source_location last = pfile->opentoksrc_loc;
+	  /* 414:=>:TOK      [ g */
+	  pfile->cb.parse_info_cb.gen_parse_info_header(mresult->tokid,pfile->line_table->highest_line/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+	  pfile->cb.parse_info_cb.gen_parse_info_printf("=>%s:",pfile->state.in_directive ? "#" : "");
+	  pfile->cb.parse_info_cb.gen_parse_info_token(mresult);
+	  pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+          
+          /*        408     (2.3)   #GRP     [( */
+          pfile->cb.parse_info_cb.gen_parse_info_header(0,pfile->opentoksrc_loc/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+          pfile->cb.parse_info_cb.gen_parse_info_printf("%s:GRP\t[(\n",pfile->state.in_directive ? "#" : "");
+          for (i = 0; i < macro->paramc; i++) {
+              arg = &args[i];
+              if (i) {
+                  pfile->cb.parse_info_cb.gen_parse_info_header(0,last/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+                  pfile->cb.parse_info_cb.gen_parse_info_printf("%s:GRP\t[,\n",pfile->state.in_directive ? "#" : "");
+              }
+              for(j = 0; j < arg->count; j++) {
+                  if (arg->first[j]) {
+                      last = arg->first[j]->src_loc;
+                      /*     407     (1)     .c1:NAME        [g */
+                      pfile->cb.parse_info_cb.gen_parse_info_header(arg->first[j]->tokid,arg->first[j]->src_loc,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+                      pfile->cb.parse_info_cb.gen_parse_info_printf("%s\t",pfile->state.in_directive ? "#" : "");
+                      pfile->cb.parse_info_cb.gen_parse_info_write((char *)NODE_NAME (macro->params[i]),
+                                                                   NODE_LEN (macro->params[i]));
+                      pfile->cb.parse_info_cb.gen_parse_info_char(":\t");
+                      pfile->cb.parse_info_cb.gen_parse_info_token(arg->first[j]);
+                      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+                  }
+              }
+          }
+          
+          /*        408     (2.3)   #GRP     [) */
+          pfile->cb.parse_info_cb.gen_parse_info_header(0,pfile->closetoksrc_loc/*mresult->src_loc*/,pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt);
+          pfile->cb.parse_info_cb.gen_parse_info_printf("%s:GRP\t[)\n",pfile->state.in_directive ? "#" : "");
+
+      }
+      
+      
+      mdef = (char *)cpp_macro_definition (pfile, node); 
+      
+      /*	<=381   (2.3)   #NAME          [b]:test.c@4:@#define b(b) b + 1  */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t<=%d\t",mresult->tokid);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tNAME\t[");
+      pfile->cb.parse_info_cb.gen_parse_info_write((const char*)NODE_NAME (node), (int)NODE_LEN (node));
+      pfile->cb.parse_info_cb.gen_parse_info_printf("](@%d)#",macro->macroid);
+      pfile->cb.parse_info_cb.gen_parse_info_loc(macro->line);
+      pfile->cb.parse_info_cb.gen_parse_info_printf("#%s\n",mdef);
+      
+      /*        408     (2.3)   #GRP     [( */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0 /*pfile->opentokid */);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[(\n");
+      
+  }
 
   /* First, fully macro-expand arguments, calculating the number of
      tokens in the final expansion as we go.  The ordering of the if
@@ -805,7 +1110,39 @@
   total = macro->count;
   limit = macro->exp.tokens + macro->count;
 
-  for (src = macro->exp.tokens; src < limit; src++)
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+      for (i = 0; i < macro->paramc; i++) {
+          arg = &args[i];
+	  if (i) {
+		  /*     407     (1)     # GRP        [, */
+		  pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",0);
+		  pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+		  pfile->cb.parse_info_cb.gen_parse_info_char("\t#\tGRP\t[,\n");
+	  }
+	  
+          for(j = 0; j < arg->count; j++) {
+              if (arg->first[j]) {
+ 
+		  /*     407     (1)     .c1:   NAME        [g */
+		  pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",arg->first[j]->tokid);
+		  pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+                  pfile->cb.parse_info_cb.gen_parse_info_char("\t");
+                  pfile->cb.parse_info_cb.gen_parse_info_write((char *)NODE_NAME (macro->params[i]),
+                                                               NODE_LEN (macro->params[i]));
+		  pfile->cb.parse_info_cb.gen_parse_info_char(":\t");
+                  pfile->cb.parse_info_cb.gen_parse_info_token(arg->first[j]);
+                  pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+              }
+          }
+      }
+
+      /*        408     (2.3)   #CLOSE_PAREN     [) */
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t", 0/*pfile->opentokid */);
+      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'(',')');
+      pfile->cb.parse_info_cb.gen_parse_info_printf("\t#\tGRP\t[)\n");
+  }
+
+  for (mpos = 0, src = macro->exp.tokens; src < limit; src++, mpos++)
     if (src->type == CPP_MACRO_ARG)
       {
 	/* Leading and trailing padding tokens.  */
@@ -825,29 +1162,72 @@
 	  total += arg->count - 1;
 	else
 	  {
-	    if (!arg->expanded)
+            if (!arg->expanded) {
+                pfile->state.replace_args++;
 	      expand_arg (pfile, arg);
+                pfile->state.replace_args--;
+            }
 	    total += arg->expanded_count - 1;
 	  }
       }
 
   /* Now allocate space for the expansion, copy the tokens and replace
      the arguments.  */
-  buff = _cpp_get_buff (pfile, total * sizeof (cpp_token *));
-  first = (const cpp_token **) buff->base;
+  buff = _cpp_get_buff (pfile, (total + 2) * sizeof (cpp_token *));
+  cfirst = first = (const cpp_token **) buff->base;
+  
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+	  ptok  = create_parseinfo_token(pfile, macro);
+      ptok->val.parseinfostack = oreplaceid;
+      *first++ = ptok;
+  }
+
   dest = first;
 
-  for (src = macro->exp.tokens; src < limit; src++)
+  for (mpos = 0, src = macro->exp.tokens; src < limit; src++, mpos++)
     {
       unsigned int count;
       const cpp_token **from, **paste_flag;
 
       if (src->type != CPP_MACRO_ARG)
 	{
+            if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+		
+	        /* 398     [1]     	    |PLUS        [+ */
+		pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",src->tokid);
+		pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+		pfile->cb.parse_info_cb.gen_parse_info_char("\t\t");
+		pfile->cb.parse_info_cb.gen_parse_info_char("|\t");
+		pfile->cb.parse_info_cb.gen_parse_info_token(src);
+
+		{
+		    /* insert a special sequence for \\ */
+		    int i = 0; 
+		    for (i = 0; i < macro->notecnt; i++) {
+			if (macro->note[i] == (int)mpos) {
+			    pfile->cb.parse_info_cb.gen_parse_info_char("@@\\@@");
+                            ((cpp_token *)src)->flags |= CPP_MACRO_NEWLINE;
+			}
+		    }
+		}
+		pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+            }
+            
+            if (CPP_OPTION (pfile, fpreprocessnewline)) {
+                /* mark \\ for preprocess output */
+                int i = 0; 
+                for (i = 0; i < macro->notecnt; i++) {
+                    if (macro->note[i] == (int)mpos) {
+                        ((cpp_token *)src)->flags |= CPP_MACRO_NEWLINE;
+                    }
+                }
+            }
+            
 	  *dest++ = src;
 	  continue;
 	}
 
+      firstdest = dest;
       paste_flag = 0;
       arg = &args[src->val.arg_no - 1];
       if (src->flags & STRINGIFY_ARG)
@@ -895,8 +1275,11 @@
 	}
 
       /* Avoid paste on RHS (even case count == 0).  */
-      if (!pfile->state.in_directive && !(src->flags & PASTE_LEFT))
+      if (!pfile->state.in_directive && !(src->flags & PASTE_LEFT)) {
+        ((cpp_token *)&pfile->avoid_paste)->src_loc = src->src_loc;
+        ((cpp_token *)&pfile->avoid_paste)->tokid = tokid++;
 	*dest++ = &pfile->avoid_paste;
+      }
 
       /* Add a new paste flag, or remove an unwanted one.  */
       if (paste_flag)
@@ -910,6 +1293,21 @@
 	    token->flags = (*paste_flag)->flags & ~PASTE_LEFT;
 	  *paste_flag = token;
 	}
+      
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+          int i; 
+          for(i = 0; i < dest-firstdest; i++) {
+	      /* 396     [1]     	    .c1:PADDING     [ */
+	      pfile->cb.parse_info_cb.gen_parse_info_printf("\t%d\t",firstdest[i]->tokid);
+	      pfile->cb.parse_info_cb.gen_parse_info_path_direct(pfile->cb.parse_info_cb.path,pfile->cb.parse_info_cb.pathcnt,oreplaceid,'[',']');
+	      pfile->cb.parse_info_cb.gen_parse_info_char("\t\t.");
+	      pfile->cb.parse_info_cb.gen_parse_info_write((char *)NODE_NAME (macro->params[src->val.arg_no - 1]),
+							   NODE_LEN (macro->params[src->val.arg_no - 1]));
+	      pfile->cb.parse_info_cb.gen_parse_info_char(":\t");
+	      pfile->cb.parse_info_cb.gen_parse_info_token(firstdest[i]);
+	      pfile->cb.parse_info_cb.gen_parse_info_char("\n");
+          }
+      }
     }
 
   /* Free the expanded arguments.  */
@@ -917,7 +1315,14 @@
     if (args[i].expanded)
       free (args[i].expanded);
 
-  push_ptoken_context (pfile, node, buff, first, dest - first);
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info) {
+	  ptok  = create_parseinfo_token(pfile, macro);
+      ptok->val.parseinfostack = -oreplaceid;
+      *dest++ = ptok;
+  }
+
+  push_ptoken_context (pfile, node, buff, cfirst, dest - cfirst);
+
 }
 
 /* Return a special padding token, with padding inherited from SOURCE.  */
@@ -932,6 +1337,8 @@
      need a cast here.  */
   result->val.source = (cpp_token *) source;
   result->flags = 0;
+  if (pfile->cb.parse_info_cb.flag_gen_parse_info)
+      result->src_loc = source->src_loc;
   return result;
 }
 
@@ -1084,8 +1491,10 @@
       cpp_context *context = pfile->context;
 
       /* Context->prev == 0 <=> base context.  */
-      if (!context->prev)
+      if (!context->prev) {
 	result = _cpp_lex_token (pfile);
+        pfile->__line__ = result->src_loc;
+      }
       else if (FIRST (context).token != LAST (context).token)
 	{
 	  if (context->direct_p)
@@ -1093,6 +1502,11 @@
 	  else
 	    result = *FIRST (context).ptoken++;
 
+          if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+              handle_parseinfo(pfile,result)) {
+              continue;
+          }
+          
 	  if (result->flags & PASTE_LEFT)
 	    {
 	      paste_all_tokens (pfile, result);
@@ -1112,6 +1526,11 @@
       if (pfile->state.in_directive && result->type == CPP_COMMENT)
 	continue;
 
+      if (pfile->cb.parse_info_cb.flag_gen_parse_info &&
+          handle_parseinfo(pfile,result)) {
+          continue;
+      }
+      
       if (result->type != CPP_NAME)
 	break;
 
@@ -1122,13 +1541,15 @@
 
       if (!(node->flags & NODE_DISABLED))
 	{
+
 	  if (!pfile->state.prevent_expansion
-	      && enter_macro_context (pfile, node))
+	      && enter_macro_context (pfile, node, result))
 	    {
 	      if (pfile->state.in_directive)
 		continue;
 	      return padding_token (pfile, result);
 	    }
+          
 	}
       else
 	{
@@ -1522,8 +1943,19 @@
 	{
 	  /* Token-paste ##, can appear in both object-like and
 	     function-like macros, but not at the ends.  */
-	  if (--macro->count > 0)
+            if (--macro->count > 0) {
+                if ((pfile->state.save_spaces)) {
+                    while(macro->count && token->type == CPP_COMMENT) {
+                        --macro->count; --token;
+                    }
+                }
+	    token = lex_expansion_token (pfile, macro);
+                while ((pfile->state.save_spaces) &&
+                    token->type == CPP_COMMENT) {
+                    --macro->count; 
 	    token = lex_expansion_token (pfile, macro);
+                }
+            }
 
 	  if (macro->count == 0 || token->type == CPP_EOF)
 	    {
@@ -1563,6 +1995,44 @@
   return true;
 }
 
+int macroid = 1;
+
+void _cpp_macro_dep_push (cpp_reader *pfile, cpp_macro *macro1, cpp_macro *macro2) {
+	int cnt = macro1->depend_cnt;
+	if (pfile->cb.parse_info_cb.flag_gen_dep_info) {
+		int i = 0;
+		for(i = 0;  i < macro1->depend_cnt; i++) {
+			if (macro1->depend[i] == macro2)
+				break;
+		}
+		if (macro2 == 0) {
+			/*fprintf(stderr,"Null\n");*/
+		}
+		if (macro2 && i == macro1->depend_cnt) {
+			/* fprintf(stderr,"In\n"); */
+			if(macro1->depend_cnt++) {
+				macro1->depend = XRESIZEVEC(cpp_macro *,macro1->depend,macro1->depend_cnt);
+			} else {
+				macro1->depend = XNEWVEC(cpp_macro *,macro1->depend_cnt);
+			} 	
+			macro1->depend[cnt] = macro2;
+		}
+	}
+}
+
+int _cpp_all_macros_cnt = 0;
+struct cpp_macro **_cpp_all_macros = 0;
+
+void add_cpp_all_macros(cpp_macro *macro) {
+	if(_cpp_all_macros_cnt++) {
+		_cpp_all_macros = XRESIZEVEC(cpp_macro *,_cpp_all_macros,_cpp_all_macros_cnt);
+	} else {
+		_cpp_all_macros = XNEWVEC(cpp_macro *,_cpp_all_macros_cnt);
+	} 	
+	_cpp_all_macros[_cpp_all_macros_cnt-1] = macro;
+}
+
+
 /* Parse a macro and save its expansion.  Returns nonzero on success.  */
 bool
 _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)
@@ -1580,11 +2050,26 @@
   macro->params = 0;
   macro->paramc = 0;
   macro->variadic = 0;
+  macro->depend = 0;
+  macro->depend_cnt = 0;
   macro->used = !CPP_OPTION (pfile, warn_unused_macros);
   macro->count = 0;
   macro->fun_like = 0;
   /* To suppress some diagnostics.  */
   macro->syshdr = pfile->buffer && pfile->buffer->sysp != 0;
+  macro->macroid = macroid++;
+  macro->name = 0;
+  if (pfile->cb.parse_info_cb.flag_gen_dep_info ) {
+	  macro->name = XNEWVEC(char ,NODE_LEN (node) + 2);
+	  memcpy (macro->name, NODE_NAME (node), NODE_LEN (node));
+	  macro->name[NODE_LEN (node)] = 0;
+  }
+  
+  add_cpp_all_macros(macro);
+  
+  if (pfile->buffer && pfile->buffer->if_stack && pfile->buffer->if_stack->depend) {
+	  _cpp_macro_dep_push(pfile, macro, pfile->buffer->if_stack->depend);
+  } 
 
   if (CPP_OPTION (pfile, traditional))
     ok = _cpp_create_trad_definition (pfile, macro);
@@ -1592,7 +2077,9 @@
     {
       cpp_token *saved_cur_token = pfile->cur_token;
 
+      pfile->curmacro = macro;
       ok = create_iso_definition (pfile, macro);
+      pfile->curmacro = 0;
 
       /* Restore lexer position because of games lex_expansion_token()
 	 plays lexing the macro.  We set the type for SEEN_EOL() in
