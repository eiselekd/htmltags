diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-aux-info.c gcc-4.4.7/gcc/c-aux-info.c
--- gcc-4.4.7.ori/gcc/c-aux-info.c	2017-02-12 09:19:44.003901290 +0100
+++ gcc-4.4.7/gcc/c-aux-info.c	2017-02-12 09:19:44.239891488 +0100
@@ -298,13 +298,33 @@
    string onto the returned "seed".  */
 
 static const char *
-gen_type (const char *ret_val, tree t, formals_style style)
+gen_type_real (const char *ret_val, tree t, formals_style style, int dostruct)
 {
-  tree chain_p;
+    tree chain_p; int i;
+  char buff2[64]; char *b;
 
   /* If there is a typedef name for this type, use it.  */
-  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)
-    data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));
+  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL && !dostruct) {
+      int pcnt = 0;
+      b = buff2;
+      tree pt = gen_parse_info_getrealtype(TREE_TYPE (TYPE_NAME (t)),&pcnt);
+      for(i = 0; i < pcnt;i++) {
+          *b = '*'; b++;
+      } 
+      *b = 0;
+      data_type = concat (buff2, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t))), NULL);
+      if (TREE_CODE (pt) == RECORD_TYPE ||
+	  TREE_CODE (pt) == RECORD_TYPE ||
+	  TREE_CODE (pt) == ENUMERAL_TYPE ) {
+          
+          if (flag_gen_parse_info) { 
+	      sprintf (buff2, "@(%d)->@(%d)", DECL_DECLID (TYPE_NAME (t)),TYPE_STRUCTID(pt));
+	  } else {
+	      strcpy (buff2, "");
+	  }
+	  data_type = concat (buff2, data_type, NULL);
+      }
+  }
   else
     {
       switch (TREE_CODE (t))
@@ -364,7 +384,13 @@
 	   whole darn type specification.  Yuck!  */
 
 	case RECORD_TYPE:
-	  if (TYPE_NAME (t))
+ 	  if (flag_gen_parse_info) {
+	      sprintf (buff2, "@(%d)", TYPE_STRUCTID(t));
+	  } else {
+	      strcpy (buff2, "");
+	  }
+	  
+	  if (TYPE_NAME (t) && !dostruct)
 	    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));
 	  else
 	    {
@@ -378,12 +404,25 @@
 		  data_type = concat (data_type, "; ", NULL);
 		}
 	      data_type = concat ("{ ", data_type, "}", NULL);
+
+	      if (TYPE_NAME (t)) {
+		      data_type = concat (IDENTIFIER_POINTER (TYPE_NAME (t)), " ", data_type, NULL);
+	      }
+	  
 	    }
-	  data_type = concat ("struct ", data_type, NULL);
+	  
+	  data_type = concat (buff2,"struct ", data_type, NULL);
 	  break;
 
+	    
 	case UNION_TYPE:
-	  if (TYPE_NAME (t))
+	  if (flag_gen_parse_info) {
+	      sprintf (buff2, "@(%d)", TYPE_STRUCTID(t));
+	  } else {
+	      strcpy (buff2, "");
+	  }
+
+	  if (TYPE_NAME (t) && !dostruct)
 	    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));
 	  else
 	    {
@@ -398,10 +437,19 @@
 		}
 	      data_type = concat ("{ ", data_type, "}", NULL);
 	    }
-	  data_type = concat ("union ", data_type, NULL);
+	  if (TYPE_NAME (t)) {
+	      data_type = concat (IDENTIFIER_POINTER (TYPE_NAME (t)), " ", data_type, NULL);
+	  }
+	  data_type = concat (buff2,"union ", data_type, NULL);
 	  break;
 
 	case ENUMERAL_TYPE:
+          if (flag_gen_parse_info) {
+	      sprintf (buff2, "@(%d)", TYPE_STRUCTID(t));
+	  } else {
+	      strcpy (buff2, "");
+	  }
+
 	  if (TYPE_NAME (t))
 	    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));
 	  else
@@ -418,7 +466,7 @@
 		}
 	      data_type = concat ("{ ", data_type, " }", NULL);
 	    }
-	  data_type = concat ("enum ", data_type, NULL);
+	  data_type = concat (buff2,"enum ", data_type, NULL);
 	  break;
 
 	case TYPE_DECL:
@@ -427,7 +475,11 @@
 
 	case INTEGER_TYPE:
 	case FIXED_POINT_TYPE:
+	  if (TYPE_NAME (t)) {
 	  data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));
+	  } else {
+	    data_type = "int";
+	  }
 	  /* Normally, `unsigned' is part of the deal.  Not so if it comes
 	     with a type qualifier.  */
 	  if (TYPE_UNSIGNED (t) && TYPE_QUALS (t))
@@ -435,7 +487,11 @@
 	  break;
 
 	case REAL_TYPE:
+	  if (TYPE_NAME (t)) {
 	  data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));
+	  } else {
+	    data_type = "float";
+	  }
 	  break;
 
 	case VOID_TYPE:
@@ -446,7 +502,13 @@
 	  data_type = "[ERROR]";
 	  break;
 
+	case REFERENCE_TYPE:
+	  data_type = "&";
+	  break;
+	  
 	default:
+	    printf("unknown code %d %d\n",REFERENCE_TYPE, TREE_CODE (t));
+	    
 	  gcc_unreachable ();
 	}
     }
@@ -459,6 +521,12 @@
   return ret_val;
 }
 
+static const char *
+gen_type (const char *ret_val, tree t, formals_style style)
+{
+    return gen_type_real (ret_val, t, style, 0);
+}
+
 /* Generate a string (source) representation of an entire entity declaration
    (using some particular style for function types).
 
@@ -551,7 +619,7 @@
 gen_aux_info_record (tree fndecl, int is_definition, int is_implicit,
 		     int is_prototyped)
 {
-  if (flag_gen_aux_info)
+  if (flag_gen_aux_info || flag_gen_parse_info)
     {
       static int compiled_from_record = 0;
       expanded_location xloc = expand_location (DECL_SOURCE_LOCATION (fndecl));
@@ -559,7 +627,11 @@
       /* Each output .X file must have a header line.  Write one now if we
 	 have not yet done so.  */
 
-      if (!compiled_from_record++)
+      if (flag_gen_parse_info) {
+          fprintf (aux_info_file, "##");
+      }
+      
+      if ((!flag_gen_parse_info) && !compiled_from_record++)
 	{
 	  /* The first line tells which directory file names are relative to.
 	     Currently, -aux-info works only for files in the working
@@ -589,3 +661,49 @@
       fprintf (aux_info_file, "\n");
     }
 }
+
+char *
+gen_aux_info_type_str (tree type)
+{
+	const char *ret_val = "";
+	ret_val = gen_type (ret_val, type, ansi);
+	ret_val = affix_data_type (ret_val);
+	return ret_val;
+}
+
+#include <ctype.h>
+
+char *
+gen_aux_info_type_str_canonical (tree type)
+{
+	char *ret_val = "";
+	int p = flag_gen_parse_info, i;
+	flag_gen_parse_info = 0;
+	ret_val = gen_aux_info_type_str(type);
+	flag_gen_parse_info = p;
+	for (i = strlen(ret_val)-1; i > 0; i--) {
+		if (isblank(ret_val[i])) {
+			ret_val[i] = 0;
+		} else {
+			break;
+		}
+	}
+	for (i = 0; i < strlen(ret_val); i++) {
+		if (isblank(ret_val[i]) || !ISPRINT(ret_val[i])) {
+			ret_val[i] = '_';
+		} else if (ret_val[i] == '*') {
+			ret_val[i] = 'P';
+		}
+	}
+	return ret_val;
+}
+
+void
+gen_aux_info_type (tree type)
+{
+    if (aux_info_file) {
+	const char *ret_val = "";
+	ret_val = gen_aux_info_type_str (type);
+	fprintf (aux_info_file,ret_val);
+    }
+}
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-decl.c gcc-4.4.7/gcc/c-decl.c
--- gcc-4.4.7.ori/gcc/c-decl.c	2017-02-12 09:19:43.999901456 +0100
+++ gcc-4.4.7/gcc/c-decl.c	2017-02-12 09:19:44.239891488 +0100
@@ -64,6 +64,9 @@
 #include "pointer-set.h"
 #include "gimple.h"
 
+static int structid = 1;
+static int declid = 1;
+
 /* In grokdeclarator, distinguish syntactic contexts of declarators.  */
 enum decl_context
 { NORMAL,			/* Ordinary declaration */
@@ -4678,6 +4681,20 @@
       if (type_quals)
 	type = c_build_qualified_type (type, type_quals);
       decl = build_decl (TYPE_DECL, declarator->u.id, type);
+      DECL_DECLID (decl) = structid++;
+
+      if (flag_gen_parse_info && declspecs && declspecs->type && aux_info_file) {
+          fprintf (aux_info_file, "%d <=[ tdef (@%d->d@%d) [", declspecs->tokid,TYPE_STRUCTID(type),DECL_DECLID (decl));
+	  gen_parse_info_type (type);
+	  fprintf (aux_info_file, ":%s", IDENTIFIER_POINTER(declarator->u.id));
+	  fprintf (aux_info_file, "] decl [");
+	  gen_parse_info_loc_t(declspecs->loc);
+	  fprintf (aux_info_file, "]-[");
+          gen_parse_info_loc_t(input_location);
+	  fprintf (aux_info_file, "]\n");
+	  fflush(aux_info_file);
+      }
+      
       DECL_SOURCE_LOCATION (decl) = declarator->id_loc;
       if (declspecs->explicit_signed_p)
 	C_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;
@@ -4734,6 +4751,33 @@
 
   {
     tree decl;
+    int cdeclid = declid++;
+    
+    if (flag_gen_parse_info && declspecs && declspecs->type && aux_info_file) {
+        const char *decltyp = " decl ";
+	switch(decl_context) {
+	case PARM: decltyp = "(decl)"; break;
+	case FIELD: decltyp = "{decl}"; break;
+	case FUNCTION_TYPE: decltyp = "decl()"; break;
+	default: break;
+	}
+	
+	if (decl_context != FIELD) {
+	    fprintf (aux_info_file, "%d(@%d) <=[%s [",declspecs->tokid, cdeclid, decltyp);
+	    gen_parse_info_type (type);
+	    fprintf (aux_info_file, ":%s", declarator->u.id ? IDENTIFIER_POINTER(declarator->u.id) : "<abstrace>");
+	    fprintf (aux_info_file, "] at [");
+            gen_parse_info_loc_t(declspecs->loc);
+            fprintf (aux_info_file, "]-[");
+            gen_parse_info_loc_t(input_location);
+            fprintf (aux_info_file, "] type(@%d) [",TYPE_STRUCTID(type));
+            gen_parse_info_type (type);
+	    fprintf (aux_info_file, "] decl(@%d) at: ",declspecs->typedef_declid);
+	    gen_parse_info_loc_t(TYPE_LOCATION(gen_parse_info_getrealtype(type,0)));
+	    fprintf (aux_info_file, "\n");
+	    fflush(aux_info_file);
+	}
+    }
 
     if (decl_context == PARM)
       {
@@ -4816,6 +4860,7 @@
 	decl = build_decl (FIELD_DECL, declarator->u.id, type);
 	DECL_SOURCE_LOCATION (decl) = declarator->id_loc;
 	DECL_NONADDRESSABLE_P (decl) = bitfield;
+	FIELD_DECL_TOKID(decl) = declspecs->tokid;
 	if (bitfield && !declarator->u.id)
 	  TREE_NO_WARNING (decl) = 1;
 
@@ -4961,6 +5006,10 @@
 	  DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
       }
 
+    if (decl) {
+        DECL_DECLID (decl) = cdeclid;
+    }
+    
     if (storage_class == csc_extern
 	&& variably_modified_type_p (type, NULL_TREE))
       {
@@ -5319,6 +5368,11 @@
   ret.kind = (ref ? ctsk_tagref : ctsk_tagfirstref);
   if (ref && TREE_CODE (ref) == code)
     {
+	    if (TYPE_DEP(ref)) {
+		    if (flag_gen_dep_info) {
+			    dep_add_top(TYPE_DEP(ref));
+		    }
+	    }
       ret.spec = ref;
       return ret;
     }
@@ -5342,6 +5396,11 @@
       TYPE_MAX_VALUE (ref) = TYPE_MAX_VALUE (unsigned_type_node);
     }
 
+  if (code == RECORD_TYPE ||
+      code == UNION_TYPE) {
+        TYPE_STRUCTID(ref) = structid++;
+  }
+
   pushtag (name, ref);
 
   ret.spec = ref;
@@ -5363,7 +5422,7 @@
    CODE says which kind of tag NAME ought to be.  */
 
 tree
-start_struct (enum tree_code code, tree name)
+start_struct (enum tree_code code, tree name, location_t loc)
 {
   /* If there is already a tag defined at this scope
      (as a forward reference), just return it.  */
@@ -5392,6 +5451,8 @@
 	  /* Don't create structures that contain themselves.  */
 	  ref = NULL_TREE;
 	}
+      if (ref)
+	TYPE_LOCATION(ref) = loc;
     }
 
   /* Otherwise create a forward-reference just so the tag is in scope.  */
@@ -5400,6 +5461,10 @@
     {
       ref = make_node (code);
       pushtag (name, ref);
+      TYPE_LOCATION(ref) = loc;
+    }
+  if (!TYPE_STRUCTID(ref) ) {
+    TYPE_STRUCTID(ref) = structid++;
     }
 
   C_TYPE_BEING_DEFINED (ref) = 1;
@@ -5544,7 +5609,7 @@
    ATTRIBUTES are attributes to be applied to the structure.  */
 
 tree
-finish_struct (tree t, tree fieldlist, tree attributes)
+finish_struct (tree t, tree fieldlist, tree attributes, int tokid)
 {
   tree x;
   bool toplevel = file_scope == current_scope;
@@ -5795,6 +5860,48 @@
   /* Finish debugging output for this type.  */
   rest_of_type_compilation (t, toplevel);
 
+  if (flag_gen_parse_info && aux_info_file) {
+      
+      fprintf (aux_info_file, "%d <=[%d ", tokid , TYPE_STRUCTID(t));
+      if (TREE_CODE(t) == RECORD_TYPE) {
+	  fprintf (aux_info_file, "struct ");
+      } else {
+	  fprintf (aux_info_file, "union ");
+      }
+      if (TYPE_NAME (t))
+	  fprintf (aux_info_file, "%s [",IDENTIFIER_POINTER (TYPE_NAME (t)));
+      else
+	  fprintf (aux_info_file, "<unknown> [");
+      
+      gen_parse_info_type (t);
+      fprintf (aux_info_file, "] decl started at: [");
+      gen_parse_info_loc_t(TYPE_LOCATION(t));
+      fprintf (aux_info_file, "]-[");
+      gen_parse_info_loc_t(input_location);
+      fprintf (aux_info_file, "]\n");
+      fflush(aux_info_file);
+
+      for (x = fieldlist; x; x = TREE_CHAIN (x)) {
+	  if (TREE_CODE (x) == FIELD_DECL) {
+	      fprintf (aux_info_file, "%d(@%d) <=[{decl} [",FIELD_DECL_TOKID(x),TYPE_STRUCTID(t) );
+	      fprintf (aux_info_file, "%s", DECL_NAME(x) ? IDENTIFIER_POINTER(DECL_NAME(x)) : "<abstract>");
+
+	      fprintf (aux_info_file, "] start [");
+	      gen_parse_info_loc_t(DECL_SOURCE_LOCATION (x));
+	      fprintf (aux_info_file, "] type ["/*,%04d %04d DECL_FIELD_OFFSET (x) , DECL_FIELD_BIT_OFFSET (x)*/);
+
+	      gen_parse_info_type (TREE_TYPE (x));
+	      fprintf (aux_info_file, "] decl at: ");
+	      gen_parse_info_loc_t(TYPE_LOCATION(gen_parse_info_getrealtype(TREE_TYPE (x),0)));
+	      fprintf (aux_info_file, "\n");
+	      fflush(aux_info_file);
+	  }
+      }
+  
+      
+  }
+
+  
   /* If we're inside a function proper, i.e. not file-scope and not still
      parsing parameters, then arrange for the size of a variable sized type
      to be bound now.  */
@@ -5856,6 +5963,10 @@
   the_enum->enum_next_value = integer_zero_node;
   the_enum->enum_overflow = 0;
 
+  if (!TYPE_STRUCTID(enumtype) ) {
+      TYPE_STRUCTID(enumtype) = structid++;
+  }
+  
   if (flag_short_enums)
     TYPE_PACKED (enumtype) = 1;
 
@@ -5869,9 +5980,9 @@
    Returns ENUMTYPE.  */
 
 tree
-finish_enum (tree enumtype, tree values, tree attributes)
+finish_enum (tree enumtype, tree values, tree attributes, int tokid)
 {
-  tree pair, tem;
+    tree pair, tem, x;
   tree minnode = 0, maxnode = 0;
   int precision, unsign;
   bool toplevel = (file_scope == current_scope);
@@ -5935,6 +6046,40 @@
 
   if (values != error_mark_node)
     {
+
+        if (flag_gen_parse_info && aux_info_file) {
+            
+            fprintf (aux_info_file, "%d <=[%d ", tokid , TYPE_STRUCTID(enumtype));
+            fprintf (aux_info_file, "enum ");
+            if (TYPE_NAME (enumtype))
+                fprintf (aux_info_file, "%s [",IDENTIFIER_POINTER (TYPE_NAME (enumtype)));
+            else
+                fprintf (aux_info_file, "<unknown> [");
+            
+            gen_parse_info_type (enumtype);
+            fprintf (aux_info_file, "] decl started at: [");
+            gen_parse_info_loc_t(TYPE_LOCATION(enumtype));
+            fprintf (aux_info_file, "]-[");
+            gen_parse_info_loc_t(input_location);
+            fprintf (aux_info_file, "]\n");
+            fflush(aux_info_file);
+            
+            for (x = values; x; x = TREE_CHAIN (x)) {
+                int val = -1; tree decl = TREE_PURPOSE (x);
+                if (TREE_CODE(decl) == CONST_DECL) {
+                    fprintf (aux_info_file, "%d(@%d) <=[{decl} [",decl ? CONST_DECL_TOKID(decl) : -1,TYPE_STRUCTID(enumtype) );
+                    fprintf (aux_info_file, "%s", DECL_NAME(decl) ? IDENTIFIER_POINTER(DECL_NAME(decl)) : "<abstract>");
+                    if (TREE_CODE (TREE_VALUE (x)) == INTEGER_CST) {
+                        val = TREE_INT_CST_LOW (TREE_VALUE (x));
+                    }
+                    fprintf (aux_info_file, "] value [%d",val);
+                    fprintf (aux_info_file, "]\n");
+                    fflush(aux_info_file);
+                }
+            }
+        }
+
+
       /* Change the type of the enumerators to be the enum type.  We
 	 need to do this irrespective of the size of the enum, for
 	 proper type checking.  Replace the DECL_INITIALs of the
@@ -6007,7 +6152,7 @@
    Assignment of sequential values by default is handled here.  */
 
 tree
-build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,
+build_enumerator (struct c_enum_contents *the_enum, tree name, tree value, int tokid,
 		  location_t value_loc)
 {
   tree decl, type;
@@ -6080,6 +6225,8 @@
 
   decl = build_decl (CONST_DECL, name, type);
   DECL_INITIAL (decl) = convert (type, value);
+  CONST_DECL_TOKID(decl) = tokid;
+  
   pushdecl (decl);
 
   return tree_cons (decl, value, NULL_TREE);
@@ -7173,6 +7320,9 @@
   ret->volatile_p = false;
   ret->restrict_p = false;
   ret->saturating_p = false;
+  ret->loc = input_location;
+  ret->tokid = 0;
+  ret->typedef_declid = 0;  
   return ret;
 }
 
@@ -7653,6 +7803,7 @@
 	; /* Allow the type to default to int to avoid cascading errors.  */
       else
 	{
+          specs->typedef_declid = DECL_DECLID (type);
 	  specs->type = TREE_TYPE (type);
 	  specs->decl_attr = DECL_ATTRIBUTES (type);
 	  specs->typedef_p = true;
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-lex.c gcc-4.4.7/gcc/c-lex.c
--- gcc-4.4.7.ori/gcc/c-lex.c	2017-02-12 09:19:44.003901290 +0100
+++ gcc-4.4.7/gcc/c-lex.c	2017-02-12 09:19:44.239891488 +0100
@@ -89,6 +89,35 @@
   cb->def_pragma = cb_def_pragma;
   cb->valid_pch = c_common_valid_pch;
   cb->read_pch = c_common_read_pch;
+  if (flag_gen_parse_info) {
+      /* print out "#include ..." strings from c-ppoutput.c */
+      cb->include = cb_include;
+      cpp_print.src_line = -1;
+      cpp_print.printed = 0;
+      cpp_print.prev = 0;
+      cpp_print.first_time = 1;
+      cpp_print.outf = aux_info_file;
+  }
+  
+  cb->parse_info_cb.gen_dep_info_macro = gen_dep_info_macro;
+
+  cb->parse_info_cb.gen_parse_info_token = gen_parse_info_token;
+  cb->parse_info_cb.gen_parse_info_header = gen_parse_info_header;
+  cb->parse_info_cb.gen_parse_info_char = gen_parse_info_char;
+  cb->parse_info_cb.gen_parse_info_write = gen_parse_info_write;
+  cb->parse_info_cb.gen_parse_info_loc = gen_parse_info_loc;
+  cb->parse_info_cb.gen_parse_info_loc_line = gen_parse_info_loc_line;
+  cb->parse_info_cb.gen_parse_info_printf = gen_parse_info_printf;
+  cb->parse_info_cb.gen_parse_info_header_direct = gen_parse_info_header_direct;
+  cb->parse_info_cb.flag_gen_parse_info = flag_gen_parse_info;
+  cb->parse_info_cb.flag_gen_dep_info = flag_gen_dep_info;
+
+  cb->parse_info_cb.gen_parse_info_path_direct = gen_parse_info_path_direct;
+  gen_parse_info_init(&cb->parse_info_cb);
+  cb->parse_info_cb.gen_parse_info_updateloc = gen_parse_info_updateloc;
+  
+  cb->parse_info_cb.path = 0;
+  cb->parse_info_cb.pathcnt = 0;
 
   /* Set the debug callbacks if we can use them.  */
   if (debug_info_level == DINFO_LEVEL_VERBOSE
@@ -222,6 +251,20 @@
 	    }
 #endif
 	}
+
+      if (flag_gen_parse_info) {
+	  source_location src_loc = new_map->start_location;
+	  struct cpp_callbacks *cb = cpp_get_callbacks (parse_in);
+	  location_t loc = gen_parse_info_src2loc (src_loc);
+          int from = 0; const struct line_map *map;
+          if (! MAIN_FILE_P (new_map)) {
+              map = INCLUDED_FROM (line_table, new_map);
+              from = LAST_SOURCE_LINE (map);
+          }
+	  cb->parse_info_cb.gen_parse_info_printf("%d@# include + %s\n",from,LOCATION_FILE(loc));
+	  gen_parse_info_updateloc (&(cb->parse_info_cb), src_loc, 1);
+      }
+      
     }
   else if (new_map->reason == LC_LEAVE)
     {
@@ -235,8 +278,38 @@
 #endif
       input_location = new_map->start_location;
 
+      if (flag_gen_parse_info) {
+	  source_location src_loc = new_map->start_location;
+	  struct cpp_callbacks *cb = cpp_get_callbacks (parse_in);
+	  cb->parse_info_cb.gen_parse_info_printf("# include - \n");
+	  gen_parse_info_updateloc (&(cb->parse_info_cb), src_loc, 1);
+      }
+      
       (*debug_hooks->end_source_file) (new_map->to_line);
     }
+  else if (new_map->reason == LC_RENAME) {
+      if (flag_gen_parse_info) {
+          source_location src_loc = new_map->start_location;
+          struct cpp_callbacks *cb = cpp_get_callbacks (parse_in);
+          location_t loc = gen_parse_info_src2loc (src_loc);
+          cb->parse_info_cb.gen_parse_info_printf("# rename %s\n",LOCATION_FILE(loc));
+          gen_parse_info_updateloc (&(cb->parse_info_cb), src_loc, 1);
+      }
+  }
+  else {
+      if (flag_gen_parse_info) {
+	  source_location src_loc = new_map->start_location;
+	  struct cpp_callbacks *cb = cpp_get_callbacks (parse_in);
+	  location_t loc = gen_parse_info_src2loc (src_loc);
+          int from = 0; const struct line_map *map;
+          if (! MAIN_FILE_P (new_map)) {
+              map = INCLUDED_FROM (line_table, new_map);
+              from = LAST_SOURCE_LINE (map);
+          }
+	  cb->parse_info_cb.gen_parse_info_printf("%d@# include ???\n",from,LOCATION_FILE(loc));
+	  gen_parse_info_updateloc (&(cb->parse_info_cb), src_loc, 1);
+      }
+  }
 
   update_header_times (new_map->to_file);
   input_location = new_map->start_location;
@@ -288,25 +361,71 @@
 			 (const char *) NODE_NAME (node));
 }
 
+
+static void c_lex_outtoken(const cpp_token *tok) {
+    enum cpp_ttype type;
+    
+    if (flag_gen_parse_info && aux_info_file) {
+	struct cpp_callbacks *cb;
+	type = tok->type;
+	cb = cpp_get_callbacks (parse_in);
+	if (cb->parse_info_cb.pathcnt == 0 && type != CPP_PADDING)
+	    cb->parse_info_cb.gen_parse_info_updateloc(&cb->parse_info_cb, tok->src_loc,0);
+	
+	gen_parse_info_header(tok->tokid,tok->src_loc,cb->parse_info_cb.path,cb->parse_info_cb.pathcnt);
+	fprintf (aux_info_file, ":");
+	gen_parse_info_token (tok);
+	fprintf (aux_info_file, "\n");
+	
+	if (type == CPP_COMMENT) {
+	    unsigned int i;
+	    for(i = 0; i < tok->val.str.len; i++) {
+		if (tok->val.str.text[i] == '\n'){
+		    cb->parse_info_cb.src_line++;
+		}
+	    }
+	}
+	
+	fflush(aux_info_file);
+    }
+}
+
+extern int macro_stack_size;
+extern cpp_macro **macro_stack;
+
 /* Read a token and return its type.  Fill *VALUE with its value, if
    applicable.  Fill *CPP_FLAGS with the token's flags, if it is
    non-NULL.  */
 
 enum cpp_ttype
 c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,
+		  int *tokid, struct cpp_macro **macro,
 		  int lex_flags)
 {
   static bool no_more_pch;
   const cpp_token *tok;
   enum cpp_ttype type;
   unsigned char add_flags = 0;
+  if (macro)
+	  *macro = 0;
 
   timevar_push (TV_CPP);
  retry:
   tok = cpp_get_token_with_location (parse_in, loc);
   type = tok->type;
 
+  if (macro_stack_size && macro)
+	  *macro = macro_stack[0];
+  
+  if (flag_gen_parse_info && aux_info_file) {
+      c_lex_outtoken(tok);
+  }  
+  
  retry_after_at:
+
+  if (tokid)
+    *tokid = tok->tokid;
+  
   switch (type)
     {
     case CPP_PADDING:
@@ -436,9 +555,15 @@
       *value = build_int_cst (NULL, tok->val.pragma);
       break;
 
+    case CPP_COMMENT:
+	if (flag_gen_parse_info && aux_info_file) {
+	    goto retry;
+	}
+	/* fall through */
+	
       /* These tokens should not be visible outside cpplib.  */
     case CPP_HEADER_NAME:
-    case CPP_COMMENT:
+    case CPP_PARSEINFOSTACK:
     case CPP_MACRO_ARG:
       gcc_unreachable ();
 
@@ -866,10 +991,16 @@
     {
     case CPP_PADDING:
       goto retry;
+    case CPP_COMMENT:
+	if (flag_gen_parse_info && aux_info_file)
+	    c_lex_outtoken(tok);
+      goto retry;
     case CPP_ATSIGN:
       if (c_dialect_objc ())
 	{
 	  objc_string = true;
+	  if (flag_gen_parse_info && aux_info_file)
+	      c_lex_outtoken(tok);
 	  goto retry;
 	}
       /* FALLTHROUGH */
@@ -889,6 +1020,8 @@
 	}
 
     case CPP_STRING:
+	if (flag_gen_parse_info && aux_info_file)
+	  c_lex_outtoken(tok);
       if (!concats)
 	{
 	  gcc_obstack_init (&str_ob);
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/common.opt gcc-4.4.7/gcc/common.opt
--- gcc-4.4.7.ori/gcc/common.opt	2017-02-12 09:19:43.999901456 +0100
+++ gcc-4.4.7/gcc/common.opt	2017-02-12 09:19:44.239891488 +0100
@@ -240,12 +240,52 @@
 aux-info=
 Common Joined
 
+ftrace-funcs
+Common Separate
+-ftrace-funcs <file>	Emit default weak trace functions to <file>
+
+ftrace-funcs=
+Common Joined
+
+ftrace-type
+Common Separate
+-ftrace-type <file>	Which kind of tracer trace_out_none,trace_out_all
+
+ftrace-type=
+Common Joined
+
 auxbase
 Common Separate
 
 auxbase-strip
 Common Separate
 
+fparse-info-file=
+Common Joined
+
+fparse-info-file
+Common Separate
+-fparse-info-file <file>	Auto generated parseinfo file suggestion
+
+fparse-info=
+Common Joined
+
+fparse-info
+Common Separate
+-fparse-info <file>	Emit parse information into <file>
+
+fparse-id=
+Common RejectNegative Joined UInteger
+-fparse-id=<number>	set parseinfo id to <number>
+
+fhtmltag-fid=
+Common RejectNegative Joined UInteger
+-htmltag-fid=<number>	set htmltag fid to <number>
+
+fhtmltag-linkid=
+Common RejectNegative Joined UInteger
+-htmltag-linkid=<number>	set htmltag linkid to <number>
+
 d
 Common Joined
 -d<letters>	Enable dumps from specific passes of the compiler
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/configure gcc-4.4.7/gcc/configure
--- gcc-4.4.7.ori/gcc/configure	2017-02-12 09:19:44.015900792 +0100
+++ gcc-4.4.7/gcc/configure	2017-02-12 09:19:44.243891322 +0100
@@ -8586,7 +8586,7 @@
 *** Info documentation will not be built." >&2;}
   BUILD_INFO=
 else
-  BUILD_INFO=info
+  BUILD_INFO=
 fi
 
 
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c.opt gcc-4.4.7/gcc/c.opt
--- gcc-4.4.7.ori/gcc/c.opt	2017-02-12 09:19:43.951903450 +0100
+++ gcc-4.4.7/gcc/c.opt	2017-02-12 09:19:44.247891156 +0100
@@ -49,6 +49,10 @@
 C ObjC C++ ObjC++
 Do not discard comments in macro expansions
 
+CCC
+C ObjC C++ ObjC++
+Do not discard spaces during preprocessing
+
 D
 C ObjC C++ ObjC++ Joined Separate
 -D<macro>[=<val>]	Define a <macro> with <val> as its value.  If just <macro> is given, <val> is taken to be 1
@@ -596,6 +600,10 @@
 C++ ObjC++
 Recognize GNU-defined keywords
 
+fdep-info
+Common Report Var(flag_gen_dep_info)
+Generate dependency tree
+
 fgnu-runtime
 ObjC ObjC++
 Generate code for GNU runtime environment
@@ -720,6 +728,10 @@
 C ObjC C++ ObjC++
 Treat the input file as already preprocessed
 
+fpreprocessnewline
+C ObjC C++ ObjC++
+Output newline in macro definition
+
 freplace-objc-classes
 ObjC ObjC++
 Used in Fix-and-Continue mode to indicate that object files may be swapped in at runtime
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-opts.c gcc-4.4.7/gcc/c-opts.c
--- gcc-4.4.7.ori/gcc/c-opts.c	2017-02-12 09:19:44.003901290 +0100
+++ gcc-4.4.7/gcc/c-opts.c	2017-02-12 09:19:44.247891156 +0100
@@ -291,11 +291,16 @@
       cpp_opts->discard_comments = 0;
       break;
 
+    case OPT_CCC:
+      cpp_opts->preserve_spaces = 1;
+      /* fallt through */
+      
     case OPT_CC:
       cpp_opts->discard_comments = 0;
       cpp_opts->discard_comments_in_macro_exp = 0;
       break;
 
+
     case OPT_D:
       defer_opt (code, arg);
       break;
@@ -746,6 +751,10 @@
       cpp_opts->preprocessed = value;
       break;
 
+    case OPT_fpreprocessnewline:
+      cpp_opts->fpreprocessnewline = value;
+      break;
+
     case OPT_freplace_objc_classes:
       flag_replace_objc_classes = value;
       break;
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/cp/Make-lang.in gcc-4.4.7/gcc/cp/Make-lang.in
--- gcc-4.4.7.ori/gcc/cp/Make-lang.in	2017-02-12 09:19:44.063898798 +0100
+++ gcc-4.4.7/gcc/cp/Make-lang.in	2017-02-12 09:19:44.247891156 +0100
@@ -73,7 +73,7 @@
 CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \
 	c-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \
 	incpath.o c-ppoutput.o c-cppbuiltin.o prefix.o \
-	c-gimplify.o c-omp.o
+	c-gimplify.o c-omp.o c-parse-info.o c-aux-info.o
 
 # Language-specific object files for C++ and Objective C++.
 CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/cp/parser.c gcc-4.4.7/gcc/cp/parser.c
--- gcc-4.4.7.ori/gcc/cp/parser.c	2017-02-12 09:19:44.063898798 +0100
+++ gcc-4.4.7/gcc/cp/parser.c	2017-02-12 09:19:44.251890990 +0100
@@ -401,7 +401,7 @@
 
    /* Get a new token from the preprocessor.  */
   token->type
-    = c_lex_with_flags (&token->u.value, &token->location, &token->flags,
+    = c_lex_with_flags (&token->u.value, &token->location, &token->flags, 0, 0,
 			lexer == NULL ? 0 : C_LEX_RAW_STRINGS);
   token->keyword = RID_MAX;
   token->pragma_kind = PRAGMA_NONE;
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-parse-info.c gcc-4.4.7/gcc/c-parse-info.c
--- gcc-4.4.7.ori/gcc/c-parse-info.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.7/gcc/c-parse-info.c	2017-02-12 09:19:44.251890990 +0100
@@ -0,0 +1,218 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "flags.h"
+#include "tree.h"
+#include "c-tree.h"
+#include "toplev.h"
+#include "cpplib.h"
+
+#define OP(sh, e, s) # sh ,
+#define TK(sh, e, s) # sh ,
+static const char * token_names[N_TTYPES] = { TTYPE_TABLE };
+
+tree gen_parse_info_getrealtype (tree t, int *p) {
+    switch (TREE_CODE (t)) {
+    case POINTER_TYPE:
+        if (p)
+            *p = *p + 1;
+        return gen_parse_info_getrealtype(TREE_TYPE (t),p);
+    default:
+        break;
+    }
+    return t;
+}
+
+location_t gen_parse_info_src2loc (source_location loc) {
+  return loc;
+  /*
+    location_t fe_loc;
+    const struct line_map *map;
+    map = linemap_lookup (line_table, loc);
+    fe_loc.file = map->to_file;
+    fe_loc.line = SOURCE_LINE (map, loc);
+    return fe_loc;*/
+}
+
+void gen_parse_info_header_direct (int tokid, source_location srcloc, int *ar, int arcnt, int dir) {
+    int *ar_ext; location_t loc;
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    loc = gen_parse_info_src2loc(srcloc);
+    ar_ext = XNEWVEC(int, arcnt + 1);
+    if (arcnt)
+        memcpy(ar_ext, ar, arcnt*sizeof(int));
+    ar_ext[arcnt] = dir;
+    gen_parse_info_header (tokid, srcloc, ar_ext, arcnt+1);
+    free(ar_ext);
+}
+
+void gen_parse_info_path_direct (int *ar, int arcnt, int dir, int copen, int cclose) {
+    int *ar_ext;
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    ar_ext = XNEWVEC(int, arcnt + 1);
+    if (arcnt)
+        memcpy(ar_ext, ar, arcnt*sizeof(int));
+    ar_ext[arcnt] = dir;
+    gen_parse_info_header_path (ar_ext, arcnt+1, copen, cclose);
+    free(ar_ext);
+}
+
+void gen_parse_info_header (int tokid, source_location srcloc, int *ar, int arcnt) {
+    location_t loc;
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    loc = gen_parse_info_src2loc(srcloc);
+    fprintf (aux_info_file, "%d@%d:",LOCATION_LINE(loc),tokid);
+    fflush(aux_info_file);
+    /*gen_parse_info_loc (srcloc);*/
+    gen_parse_info_header_path(ar,arcnt,'[',']');
+}
+
+void gen_parse_info_loc (source_location srcloc) {
+    location_t loc;
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    loc = gen_parse_info_src2loc(srcloc);
+    fprintf (aux_info_file, "%s:%d",LOCATION_FILE(loc),LOCATION_LINE(loc));
+    fflush(aux_info_file);
+}
+
+void gen_parse_info_loc_line (source_location srcloc) {
+    location_t loc;
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    loc = gen_parse_info_src2loc(srcloc);
+    fprintf (aux_info_file, "%d",LOCATION_LINE(loc));
+    fflush(aux_info_file);
+}
+
+void gen_parse_info_loc_t (location_t loc) {
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    fprintf (aux_info_file, "%s:%d",LOCATION_FILE(loc),LOCATION_LINE(loc));
+    fflush(aux_info_file);
+}
+
+/* ============ */
+
+void gen_parse_info_header_path (int *ar, int arcnt, int copen, int cclose) {
+    int i;
+    if (!(flag_gen_parse_info && aux_info_file && ar && arcnt))
+        return;
+    gen_parse_info_printf("%c", copen);
+    for (i = 0; i < arcnt; i++) {
+        if(i) 
+            gen_parse_info_char(".");
+        gen_parse_info_printf("%d",ar[i]);
+    }
+    gen_parse_info_printf("%c", cclose);
+}
+
+void gen_parse_info_type (tree type) {
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    gen_aux_info_type (type);
+}
+
+void gen_parse_info_char(const char*c) {
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    fprintf (aux_info_file, "%s",c);
+    fflush(aux_info_file);
+}
+
+void gen_parse_info_write(const char*c, int len) {
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    fwrite (c, 1, len, aux_info_file);
+    fflush(aux_info_file);
+}
+
+void gen_parse_info_token (const cpp_token *tok) {
+    char *b; int i, extrastart, count, extra = 0;
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    fprintf (aux_info_file, "%s\t[",token_names[tok->type]);
+    fflush(aux_info_file);
+    if (tok->flags & PREV_WHITE) 
+	fprintf (aux_info_file, " ");
+    b = cpp_output_token_buffer(tok);
+    count = strlen(b);
+    for(i = 0; i < count;i++) {
+        if (b[i] == '@' || b[i] == '\n' || b[i] == '\\'){
+            extra++;
+        }
+    }
+    if (extra) {
+        char *pc = XNEWVEC ( char, count + extra + 2);
+        extrastart = 0;
+        for(i = 0; i < count;i++) {
+            if (b[i] == '@' ) {
+                pc[extrastart++] = '\\';
+                pc[extrastart++] = b[i];
+            } else if (b[i] == '\n') {
+                pc[extrastart++] = '\\';
+                pc[extrastart++] = 'n';
+            } else if (b[i] == '\\') {
+                pc[extrastart++] = '\\';
+                pc[extrastart++] = '\\';
+            } else {
+                pc[extrastart++] = b[i];
+            }
+        }
+        pc[extrastart++] = 0;
+        free(b);
+        b = pc;
+    }
+    fprintf (aux_info_file, "%s",b);
+    fflush(aux_info_file);
+    free(b);
+}
+
+void gen_parse_info_printf(const char *fmt, ...) {
+    va_list ap; 
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    va_start (ap, fmt);
+    vfprintf(aux_info_file, fmt, ap);
+    va_end (ap);
+    fflush(aux_info_file);
+}
+
+void gen_parse_info_init (struct cpp_parse_info_callbacks *cb) {
+    cb->src_line = 1;
+}
+
+void gen_parse_info_updateloc (struct cpp_parse_info_callbacks *cb, source_location src_loc, int force) {
+    const struct line_map *map = linemap_lookup (line_table, src_loc);
+    int current = SOURCE_LINE (map, src_loc);
+
+    if (!(flag_gen_parse_info && aux_info_file))
+	return;
+    
+    /*fprintf(aux_info_file,"%d=>%d\n",cb->src_line,current);*/
+    if ((!force) && current >= cb->src_line && current < cb->src_line + 8) {
+        while (current > cb->src_line) {
+	    fprintf(aux_info_file,"\n");
+	    cb->src_line++;
+	}
+    } else {
+	size_t to_file_len = strlen (map->to_file);
+	unsigned char *to_file_quoted =
+	    (unsigned char *) alloca (to_file_len * 4 + 1);
+	unsigned char *p;
+	*to_file_quoted = 0;
+	p = cpp_quote_string (to_file_quoted,
+			    (unsigned char *) map->to_file, to_file_len);
+	*p = '\0';
+	cb->src_line = current;
+	fprintf(aux_info_file,"# %d %s\n",current,to_file_quoted);
+    }
+    fflush(aux_info_file);
+}
+
+
+
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-parser.c gcc-4.4.7/gcc/c-parser.c
--- gcc-4.4.7.ori/gcc/c-parser.c	2017-02-12 09:19:44.003901290 +0100
+++ gcc-4.4.7/gcc/c-parser.c	2017-02-12 09:19:44.255890823 +0100
@@ -58,6 +58,10 @@
 #include "target.h"
 #include "cgraph.h"
 
+#include "cpplib.h"
+#include "../libcpp/internal.h"
+#include "c-ppoutput.h"
+
 
 /* Initialization routine for this file.  */
 
@@ -153,6 +157,11 @@
   tree value;
   /* The location at which this token was found.  */
   location_t location;
+
+  int tokid;
+  struct cpp_macro *macro;
+  
+  
 } c_token;
 
 /* A parser structure recording information about the state and
@@ -199,6 +208,7 @@
   timevar_push (TV_LEX);
 
   token->type = c_lex_with_flags (&token->value, &token->location, NULL,
+				  &token->tokid, &token->macro, 
 				  (parser->lex_untranslated_string
 				   ? C_LEX_STRING_NO_TRANSLATE : 0));
   token->id_kind = C_ID_NONE;
@@ -250,11 +260,20 @@
 	decl = lookup_name (token->value);
 	if (decl)
 	  {
+		  if (DECL_DEP(decl)) {
+			  if (flag_gen_dep_info) {
+				  dep_add_top(DECL_DEP(decl));
+			  }
+		  }
+		  
 	    if (TREE_CODE (decl) == TYPE_DECL)
 	      {
+		      
 		token->id_kind = C_ID_TYPENAME;
 		break;
 	      }
+
+	    
 	  }
 	else if (c_dialect_objc ())
 	  {
@@ -512,6 +531,12 @@
   gcc_assert (parser->tokens[0].type != CPP_EOF);
   gcc_assert (!parser->in_pragma || parser->tokens[0].type != CPP_PRAGMA_EOL);
   gcc_assert (parser->error || parser->tokens[0].type != CPP_PRAGMA);
+
+  if (flag_gen_dep_info) {
+	  if (parser->tokens[0].macro)
+		  mdep_add_top(parser->tokens[0].macro);
+  }
+	  
   if (parser->tokens_avail == 2)
     parser->tokens[0] = parser->tokens[1];
   parser->tokens_avail--;
@@ -866,8 +891,8 @@
 static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool, bool);
 static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,
 				bool);
-static struct c_typespec c_parser_enum_specifier (c_parser *);
-static struct c_typespec c_parser_struct_or_union_specifier (c_parser *);
+static struct c_typespec c_parser_enum_specifier (c_parser *, int *);
+static struct c_typespec c_parser_struct_or_union_specifier (c_parser *, int * );
 static tree c_parser_struct_declaration (c_parser *);
 static struct c_typespec c_parser_typeof_specifier (c_parser *);
 static struct c_declarator *c_parser_declarator (c_parser *, bool, c_dtr_syn,
@@ -965,6 +990,12 @@
 static void
 c_parser_translation_unit (c_parser *parser)
 {
+  int i; 
+  memset((char *)&main_dep,0,sizeof(main_dep));
+  memset((char *)&real_dep,0,sizeof(real_dep));
+  memset((char *)&stack_dep,0,sizeof(real_dep));
+  
+
   if (c_parser_next_token_is (parser, CPP_EOF))
     {
       pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, 
@@ -981,6 +1012,39 @@
 	}
       while (c_parser_next_token_is_not (parser, CPP_EOF));
     }
+  if (flag_gen_dep_info) {
+	  FILE *f = stderr;
+	  if (aux_info_file && flag_gen_dep_info)
+		  f = aux_info_file;
+	
+	  fprintf(f,"\n<dep-info:\n");
+	  
+	  for (i = 0; i < main_dep.dep_cnt; i++) {
+		  int j; struct dep_decl *d = main_dep.dep[i];
+		  fprintf(f," dep %d: ",d->depid);
+		  fprintf (f, "[%s:%d-",LOCATION_FILE(d->start),LOCATION_LINE(d->start));
+		  fprintf (f, "%s:%d]\n  m:[",LOCATION_FILE(d->end),LOCATION_LINE(d->end));
+		  for (j = 0; j < d->mdep_cnt; j++) {
+			  cpp_macro *m = d->mdep[j];
+			  fprintf(f," %d(%s)",m->macroid,m->name ? m->name : "<NULL>");
+		  }
+		  fprintf(f,"]\n  d:[");
+		  for (j = 0; j < d->dep_cnt; j++) {
+			  fprintf(f," %d",d->dep[j]->depid);
+		  }
+		  fprintf(f,"]\n");
+		  
+	  }
+	  fprintf(f,"Macro dependencies after:\n");
+	  print_macro_dep(f);
+	  
+	  fprintf(f,"\ndep-info>\n");
+	  
+	
+
+  }
+
+  
 }
 
 /* Parse an external declaration (C90 6.7, C99 6.9).
@@ -1073,7 +1137,16 @@
       /* A declaration or a function definition.  We can only tell
 	 which after parsing the declaration specifiers, if any, and
 	 the first declarator.  */
+	    {struct dep_decl *d = 0;
+	      if (flag_gen_dep_info) {
+		      d = dep_open();
+		      dep_add(&stack_dep, d);
+	      }
       c_parser_declaration_or_fndef (parser, true, true, false, true);
+	      if (flag_gen_dep_info) {
+		      dep_pop(dep_close(d, 0));
+	      }
+	    }
       break;
     }
 }
@@ -1136,6 +1209,16 @@
    declaration:
      threadprivate-directive  */
 
+#define DEPOPEN(d) if (flag_gen_dep_info) {	\
+		d = dep_open();			\
+		dep_add(&stack_dep, d);		\
+	}
+
+#define DEPCLOSE(d) if (flag_gen_dep_info) {	\
+		dep_pop(dep_close(d, 0));	\
+	}
+
+
 static void
 c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,
 			       bool nested, bool start_attr_ok)
@@ -1145,18 +1228,23 @@
   tree all_prefix_attrs;
   bool diagnosed_no_specs = false;
   location_t here = c_parser_peek_token (parser)->location;
+  struct dep_decl *dep = 0;
+
+  DEPOPEN(dep);
 
   specs = build_null_declspecs ();
   c_parser_declspecs (parser, specs, true, true, start_attr_ok);
   if (parser->error)
     {
       c_parser_skip_to_end_of_block_or_statement (parser);
+      DEPCLOSE(dep);
       return;
     }
   if (nested && !specs->declspecs_seen_p)
     {
       c_parser_error (parser, "expected declaration specifiers");
       c_parser_skip_to_end_of_block_or_statement (parser);
+      DEPCLOSE(dep);
       return;
     }
   finish_declspecs (specs);
@@ -1170,6 +1258,7 @@
 	  pedwarn (here, 0, "empty declaration");
 	}
       c_parser_consume_token (parser);
+      DEPCLOSE(dep);
       return;
     }
   pending_xref_error ();
@@ -1230,6 +1319,8 @@
 		{
 		  maybe_warn_string_init (TREE_TYPE (d), init);
 		  finish_decl (d, init.value, asm_name);
+		  DECL_DEP(d) = dep;
+		  
 		}
 	    }
 	  else
@@ -1237,8 +1328,11 @@
 	      tree d = start_decl (declarator, specs, false,
 				   chainon (postfix_attrs,
 					    all_prefix_attrs));
-	      if (d)
+	      if (d) {     
 		finish_decl (d, NULL_TREE, asm_name);
+		DECL_DEP(d) = dep;
+	      }
+	      
 	    }
 	  if (c_parser_next_token_is (parser, CPP_COMMA))
 	    {
@@ -1253,12 +1347,14 @@
 	  else if (c_parser_next_token_is (parser, CPP_SEMICOLON))
 	    {
 	      c_parser_consume_token (parser);
+	      DEPCLOSE(dep);
 	      return;
 	    }
 	  else
 	    {
 	      c_parser_error (parser, "expected %<,%> or %<;%>");
 	      c_parser_skip_to_end_of_block_or_statement (parser);
+	      DEPCLOSE(dep);
 	      return;
 	    }
 	}
@@ -1267,6 +1363,7 @@
 	  c_parser_error (parser, "expected %<=%>, %<,%>, %<;%>, "
 			  "%<asm%> or %<__attribute__%>");
 	  c_parser_skip_to_end_of_block_or_statement (parser);
+	  DEPCLOSE(dep);
 	  return;
 	}
       /* Function definition (nested or otherwise).  */
@@ -1304,7 +1401,24 @@
       store_parm_decls ();
       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus
 	= c_parser_peek_token (parser)->location;
+
+      if (flag_gen_parse_info && aux_info_file) {
+
+	      fprintf (aux_info_file, "%d(@%d) == func%s [",specs->tokid, DECL_DECLID(current_function_decl), TREE_PUBLIC (current_function_decl) ? "^" : " ");
+	      fprintf (aux_info_file, "%s", DECL_NAME(current_function_decl) ? IDENTIFIER_POINTER(DECL_NAME(current_function_decl)) : "<abstrace>");
+	      fprintf (aux_info_file, "]\n");
+	      fflush(aux_info_file);
+
+	      fflush(aux_info_file);
+	      fprintf (aux_info_file, "{{+:%s:[\n", DECL_NAME(current_function_decl) ? IDENTIFIER_POINTER(DECL_NAME(current_function_decl)) : "<abstrace>");
+	      fflush(aux_info_file);
+      }
+      
       fnbody = c_parser_compound_statement (parser);
+      if (flag_gen_parse_info && aux_info_file) { 
+	      fprintf (aux_info_file, "}}-:%s:[\n", DECL_NAME(current_function_decl) ? IDENTIFIER_POINTER(DECL_NAME(current_function_decl)) : "<abstrace>");
+	      fflush(aux_info_file);
+      }
       if (nested)
 	{
 	  tree decl = current_function_decl;
@@ -1320,6 +1434,8 @@
 	}
       break;
     }
+  DEPCLOSE(dep);
+  
 }
 
 /* Parse an asm-definition (asm() outside a function body).  This is a
@@ -1426,6 +1542,7 @@
 c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,
 		    bool scspec_ok, bool typespec_ok, bool start_attr_ok)
 {
+  int tokid;
   bool attrs_ok = start_attr_ok;
   bool seen_type = specs->type_seen_p;
   while (c_parser_next_token_is (parser, CPP_NAME)
@@ -1438,6 +1555,7 @@
 	{
 	  tree value = c_parser_peek_token (parser)->value;
 	  c_id_kind kind = c_parser_peek_token (parser)->id_kind;
+	  tokid = c_parser_peek_token (parser)->tokid;
 	  /* This finishes the specifiers unless a type name is OK, it
 	     is declared as a type name and a type name hasn't yet
 	     been seen.  */
@@ -1466,6 +1584,7 @@
 	      t.spec = objc_get_protocol_qualified_type (value, proto);
 	    }
 	  declspecs_add_type (specs, t);
+          specs->tokid = tokid;
 	  continue;
 	}
       if (c_parser_next_token_is (parser, CPP_LESS))
@@ -1527,6 +1646,7 @@
 	  t.kind = ctsk_resword;
 	  t.spec = c_parser_peek_token (parser)->value;
 	  declspecs_add_type (specs, t);
+	  specs->tokid = c_parser_peek_token (parser)->tokid;
 	  c_parser_consume_token (parser);
 	  break;
 	case RID_ENUM:
@@ -1534,16 +1654,19 @@
 	    goto out;
 	  attrs_ok = true;
 	  seen_type = true;
-	  t = c_parser_enum_specifier (parser);
+	  specs->tokid = c_parser_peek_token (parser)->tokid;
+	  t = c_parser_enum_specifier (parser,&specs->tokid);
 	  declspecs_add_type (specs, t);
 	  break;
 	case RID_STRUCT:
 	case RID_UNION:
+	  tokid = -1;
 	  if (!typespec_ok)
 	    goto out;
 	  attrs_ok = true;
 	  seen_type = true;
-	  t = c_parser_struct_or_union_specifier (parser);
+	  specs->tokid = c_parser_peek_token (parser)->tokid;
+	  t = c_parser_struct_or_union_specifier (parser, &specs->tokid);
 	  declspecs_add_type (specs, t);
 	  break;
 	case RID_TYPEOF:
@@ -1554,6 +1677,7 @@
 	    goto out;
 	  attrs_ok = true;
 	  seen_type = true;
+	  specs->tokid = c_parser_peek_token (parser)->tokid;
 	  t = c_parser_typeof_specifier (parser);
 	  declspecs_add_type (specs, t);
 	  break;
@@ -1600,7 +1724,7 @@
 */
 
 static struct c_typespec
-c_parser_enum_specifier (c_parser *parser)
+c_parser_enum_specifier (c_parser *parser, int *tokid)
 {
   struct c_typespec ret;
   tree attrs;
@@ -1629,6 +1753,7 @@
       c_parser_consume_token (parser);
       while (true)
 	{
+            int valtok = -1;
 	  tree enum_id;
 	  tree enum_value;
 	  tree enum_decl;
@@ -1645,6 +1770,7 @@
 	    }
 	  token = c_parser_peek_token (parser);
 	  enum_id = token->value;
+	  valtok = c_parser_peek_token (parser)->tokid;
 	  /* Set the location in case we create a decl now.  */
 	  c_parser_set_source_position_from_token (token);
 	  value_loc = token->location;
@@ -1657,7 +1783,7 @@
 	    }
 	  else
 	    enum_value = NULL_TREE;
-	  enum_decl = build_enumerator (&the_enum, enum_id, enum_value, 
+	  enum_decl = build_enumerator (&the_enum, enum_id, enum_value,  valtok,
 					value_loc);
 	  TREE_CHAIN (enum_decl) = values;
 	  values = enum_decl;
@@ -1685,7 +1811,7 @@
 	}
       postfix_attrs = c_parser_attributes (parser);
       ret.spec = finish_enum (type, nreverse (values),
-			      chainon (attrs, postfix_attrs));
+			      chainon (attrs, postfix_attrs),*tokid);
       ret.kind = ctsk_tagdef;
       return ret;
     }
@@ -1748,12 +1874,15 @@
    when followed by a semicolon.)  */
 
 static struct c_typespec
-c_parser_struct_or_union_specifier (c_parser *parser)
+c_parser_struct_or_union_specifier (c_parser *parser, int *tokid)
 {
   struct c_typespec ret;
-  tree attrs;
+  tree attrs; c_token *tok = c_parser_peek_token (parser);
   tree ident = NULL_TREE;
   enum tree_code code;
+  location_t  loc = tok->location;
+  struct dep_decl *dep = 0;
+  
   switch (c_parser_peek_token (parser)->keyword)
     {
     case RID_STRUCT:
@@ -1772,13 +1901,14 @@
   if (c_parser_next_token_is (parser, CPP_NAME))
     {
       ident = c_parser_peek_token (parser)->value;
+      *tokid = c_parser_peek_token (parser)->tokid;
       c_parser_consume_token (parser);
     }
   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
     {
       /* Parse a struct or union definition.  Start the scope of the
 	 tag before parsing components.  */
-      tree type = start_struct (code, ident);
+      tree type;
       tree postfix_attrs;
       /* We chain the components in reverse order, then put them in
 	 forward order at the end.  Each struct-declaration may
@@ -1791,6 +1921,13 @@
 	 so we'll be minimizing the number of node traversals required
 	 by chainon.  */
       tree contents = NULL_TREE;
+
+      DEPOPEN(dep);
+      
+      type = start_struct (code, ident, loc);
+      
+      TYPE_LOCATION(type) = loc;
+
       c_parser_consume_token (parser);
       /* Handle the Objective-C @defs construct,
 	 e.g. foo(sizeof(struct{ @defs(ClassName) }));.  */
@@ -1868,8 +2005,13 @@
 	}
       postfix_attrs = c_parser_attributes (parser);
       ret.spec = finish_struct (type, nreverse (contents),
-				chainon (attrs, postfix_attrs));
+				chainon (attrs, postfix_attrs),*tokid);
+
+      TYPE_DEP(ret.spec) = dep;
+      
       ret.kind = ctsk_tagdef;
+      
+      DEPCLOSE(dep);
       return ret;
     }
   else if (!ident)
@@ -5093,6 +5235,7 @@
 {
   struct c_expr expr, e1, e2, e3;
   struct c_type_name *t1, *t2;
+  c_token *token;
   location_t loc;
   switch (c_parser_peek_token (parser)->type)
     {
@@ -5142,10 +5285,11 @@
       {
 	tree id = c_parser_peek_token (parser)->value;
 	location_t loc = c_parser_peek_token (parser)->location;
+	int tokid = c_parser_peek_token (parser)->tokid;
 	c_parser_consume_token (parser);
 	expr.value = build_external_ref (id,
 					 (c_parser_peek_token (parser)->type
-					  == CPP_OPEN_PAREN), loc);
+					  == CPP_OPEN_PAREN), loc, tokid);
 	expr.original_code = ERROR_MARK;
       }
       break;
@@ -5287,8 +5431,9 @@
 	       accept sub structure and sub array references.  */
 	    if (c_parser_next_token_is (parser, CPP_NAME))
 	      {
+                token = c_parser_peek_token (parser);
 		offsetof_ref = build_component_ref
-		  (offsetof_ref, c_parser_peek_token (parser)->value);
+		    (offsetof_ref, c_parser_peek_token (parser)->value, token->tokid);
 		c_parser_consume_token (parser);
 		while (c_parser_next_token_is (parser, CPP_DOT)
 		       || c_parser_next_token_is (parser,
@@ -5314,9 +5459,10 @@
 			    c_parser_error (parser, "expected identifier");
 			    break;
 			  }
+                        token = c_parser_peek_token (parser);
 			offsetof_ref = build_component_ref
 			  (offsetof_ref,
-			   c_parser_peek_token (parser)->value);
+			   c_parser_peek_token (parser)->value, token->tokid);
 			c_parser_consume_token (parser);
 		      }
 		    else
@@ -5563,6 +5709,7 @@
 c_parser_postfix_expression_after_primary (c_parser *parser,
 					   struct c_expr expr)
 {
+  c_token *token;
   tree ident, idx, exprlist;
   location_t loc = c_parser_peek_token (parser)->location;
   while (true)
@@ -5604,11 +5751,13 @@
 	      expr.original_code = ERROR_MARK;
 	      return expr;
 	    }
+          token = c_parser_peek_token (parser);
 	  c_parser_consume_token (parser);
-	  expr.value = build_component_ref (expr.value, ident);
+	  expr.value = build_component_ref (expr.value, ident, token->tokid);
 	  expr.original_code = ERROR_MARK;
 	  break;
 	case CPP_DEREF:
+          token = c_parser_peek_token (parser);
 	  /* Structure element reference.  */
 	  c_parser_consume_token (parser);
 	  expr = default_function_array_conversion (expr);
@@ -5624,8 +5773,8 @@
 	  c_parser_consume_token (parser);
 	  expr.value = build_component_ref (build_indirect_ref (loc,
 								expr.value,
-								"->"),
-					    ident);
+								"->"), /* todo: add tokid ?*/
+					    ident, token->tokid);
 	  expr.original_code = ERROR_MARK;
 	  break;
 	case CPP_PLUS_PLUS:
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-ppoutput.c gcc-4.4.7/gcc/c-ppoutput.c
--- gcc-4.4.7.ori/gcc/c-ppoutput.c	2017-02-12 09:19:44.035899961 +0100
+++ gcc-4.4.7/gcc/c-ppoutput.c	2017-02-12 09:19:44.255890823 +0100
@@ -26,18 +26,13 @@
 #include "tree.h"
 #include "c-common.h"		/* For flags.  */
 #include "c-pragma.h"		/* For parse_in.  */
+#include "c-tree.h"		/* For cb_include().  */
+#include "flags.h"		/* flag_gen_parse_info  */
 
 /* Encapsulates state used to convert a stream of tokens into a text
    file.  */
-static struct
-{
-  FILE *outf;			/* Stream to write to.  */
-  const cpp_token *prev;	/* Previous token.  */
-  const cpp_token *source;	/* Source token for spacing.  */
-  int src_line;			/* Line number currently being written.  */
-  unsigned char printed;	/* Nonzero if something output at line.  */
-  bool first_time;		/* pp_file_change hasn't been called yet.  */
-} print;
+struct cppoutput cpp_print;
+#define print cpp_print
 
 /* Defined and undefined macros being queued for output with -dU at
    the next newline.  */
@@ -69,7 +64,7 @@
 static void cb_undef (cpp_reader *, source_location, cpp_hashnode *);
 static void cb_used_define (cpp_reader *, source_location, cpp_hashnode *);
 static void cb_used_undef (cpp_reader *, source_location, cpp_hashnode *);
-static void cb_include (cpp_reader *, source_location, const unsigned char *,
+void cb_include (cpp_reader *, source_location, const unsigned char *,
 			const char *, int, const cpp_token **);
 static void cb_ident (cpp_reader *, source_location, const cpp_string *);
 static void cb_def_pragma (cpp_reader *, source_location);
@@ -111,6 +106,8 @@
 init_pp_output (FILE *out_stream)
 {
   cpp_callbacks *cb = cpp_get_callbacks (parse_in);
+  cb->parse_info_cb.flag_gen_dep_info = flag_gen_dep_info;
+  cb->parse_info_cb.gen_dep_info_macro = 0;
 
   if (!flag_no_output)
     {
@@ -179,6 +176,12 @@
       if (token->type == CPP_EOF)
 	break;
 
+      if (CPP_OPTION (pfile, fpreprocessnewline)) {
+          if (token->flags & CPP_MACRO_NEWLINE) {
+              putc ('\n', print.outf);
+          }
+      }
+      
       /* Subtle logic to output a space if and only if necessary.  */
       if (avoid_paste)
 	{
@@ -465,11 +468,16 @@
   undef_queue = NULL;
 }
 
-static void
+void
 cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,
 	    const unsigned char *dir, const char *header, int angle_brackets,
 	    const cpp_token **comments)
 {
+  if (flag_gen_parse_info) {
+      struct cpp_callbacks *cb = cpp_get_callbacks (parse_in);
+      gen_parse_info_updateloc(&(cb->parse_info_cb),line,0);
+  }
+  else 
   maybe_print_line (line);
   if (angle_brackets)
     fprintf (print.outf, "#%s <%s>", dir, header);
@@ -584,3 +592,108 @@
   fprintf (print.outf, "#pragma GCC pch_preprocess \"%s\"\n", name);
   print.src_line++;
 }
+
+
+struct dep_decl real_dep;
+struct dep_decl main_dep;
+struct dep_decl stack_dep;
+
+void gen_dep_info_macro(struct cpp_macro *m) {
+	m = 0;
+	if (stack_dep.dep_cnt) {
+		/*fprintf(stderr,"[%d] add %d<=%d\n", stack_dep.dep_cnt-1, stack_dep.dep[stack_dep.dep_cnt-1]->depid, m->macroid);*/
+		/*mdep_add(stack_dep.dep[stack_dep.dep_cnt-1], m);*/
+	}
+}
+
+void dep_pop(struct dep_decl *d0) {
+	if (stack_dep.dep_cnt == 0)
+		return;
+	if (--(stack_dep.dep_cnt) == 0) {
+		free(stack_dep.dep);
+		stack_dep.dep = 0;
+	}
+	d0 = 0;
+}
+
+void dep_add_top(struct dep_decl *d) {
+	if (stack_dep.dep_cnt){
+		dep_add(stack_dep.dep[stack_dep.dep_cnt-1], d);
+	}
+}	      
+
+void mdep_add_top(struct cpp_macro *m) {
+	if (stack_dep.dep_cnt){
+		mdep_add(stack_dep.dep[stack_dep.dep_cnt-1], m);
+	}
+}	      
+
+void dep_add(struct dep_decl *d0, struct dep_decl *d1) {
+	int cnt = d0->dep_cnt;
+	if (d0->dep_cnt++) {
+		d0->dep = (struct dep_decl **) xrealloc(d0->dep,d0->dep_cnt*sizeof(void*));
+	} else {
+		d0->dep = (struct dep_decl **) xmalloc(d0->dep_cnt*sizeof(void*));
+	}
+	d0->dep[cnt] = d1;
+}
+
+void mdep_add(struct dep_decl *d0, struct cpp_macro *m) {
+	int i;
+	for (i = 0; i < d0->mdep_cnt; i++) {
+		if (d0->mdep[i] == m)
+			break;
+	}
+	if (i == d0->mdep_cnt) {
+		int cnt = d0->mdep_cnt;
+		if (d0->mdep_cnt++) {
+			d0->mdep = (struct cpp_macro **) xrealloc(d0->mdep,d0->mdep_cnt*sizeof(void*));
+		} else {
+			d0->mdep = (struct cpp_macro **) xmalloc(d0->mdep_cnt*sizeof(void*));
+		}
+		d0->mdep[cnt] = m;
+		/*fprintf(stderr,"add at %d\n",cnt);*/
+	}
+}
+
+
+int depid = 1;
+struct dep_decl *dep_open(void) {
+	struct dep_decl *d;
+	d = (struct dep_decl *) xmalloc(sizeof(struct dep_decl));
+	memset((char *)d,0,sizeof(struct dep_decl));
+	dep_add(&main_dep,d);
+	d->depid = depid++;
+	d->start = input_location;
+	d->end = input_location;
+	return d;
+}
+
+struct dep_decl *dep_close(struct dep_decl *d, tree decl) {
+	d->decl = decl;
+	d->end = input_location;
+	return d;
+}
+
+extern int _cpp_all_macros_cnt;
+extern struct cpp_macro **_cpp_all_macros;
+
+void print_macro_dep(FILE *f );
+void print_macro_dep(FILE *f ) {
+	int i, j;
+	for(i = 0; i < _cpp_all_macros_cnt; i++) {
+		struct cpp_macro *m = _cpp_all_macros[i];
+		location_t loc;
+		loc = gen_parse_info_src2loc(m->line);
+		if (1 || m->line != 2) {
+			fprintf(f," mac %d (%s): ",m->macroid, m->name ? m->name : "<NULL>"); fflush(f);
+			fprintf (f, "[%s:%d]\n [",LOCATION_FILE(loc),LOCATION_LINE(loc)); fflush(f);
+			for (j = 0; j < m->depend_cnt; j++) {
+				cpp_macro *mac = m->depend[j];
+				fprintf(f," %d(%s)",mac->macroid, mac->name ? mac->name : "<NULL>"); fflush(f);
+			} 
+			fprintf(f,"]\n"); fflush(f);
+		}  
+	}
+}
+
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-ppoutput.h gcc-4.4.7/gcc/c-ppoutput.h
--- gcc-4.4.7.ori/gcc/c-ppoutput.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.7/gcc/c-ppoutput.h	2017-02-12 09:19:44.255890823 +0100
@@ -0,0 +1,39 @@
+#ifndef PP_OUT_P_H
+#define PP_OUT_P_H
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "cpplib.h"
+#include "../libcpp/internal.h"
+#include "tree.h"
+#include "c-common.h"		/* For flags.  */
+#include "c-pragma.h"		/* For parse_in.  */
+#include "c-tree.h"		/* For cb_include().  */
+#include "flags.h"		/* flag_gen_parse_info  */
+
+
+extern struct dep_decl real_dep;
+extern struct dep_decl main_dep;
+extern struct dep_decl stack_dep;
+
+void gen_dep_info_macro(struct cpp_macro *m) ;
+void dep_pop(struct dep_decl *d0) ;
+void dep_add_top(struct dep_decl *d) ;
+void mdep_add_top(struct cpp_macro *m) ;
+
+void dep_add(struct dep_decl *d0, struct dep_decl *d1) ;
+
+void mdep_add(struct dep_decl *d0, struct cpp_macro *m) ;
+
+
+extern int depid ;
+struct dep_decl *dep_open(void) ;
+
+struct dep_decl *dep_close(struct dep_decl *d, tree decl) ;
+
+void print_macro_dep(FILE *f ) ;
+
+
+#endif
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-pragma.h gcc-4.4.7/gcc/c-pragma.h
--- gcc-4.4.7.ori/gcc/c-pragma.h	2017-02-12 09:19:43.999901456 +0100
+++ gcc-4.4.7/gcc/c-pragma.h	2017-02-12 09:19:44.255890823 +0100
@@ -126,6 +126,7 @@
    convenient location to declare this function for c-lex, after
    having enum cpp_ttype declared.  */
 extern enum cpp_ttype c_lex_with_flags (tree *, location_t *, unsigned char *,
+					int *, struct cpp_macro **,
 					int);
 
 extern void c_pp_lookup_pragma (unsigned int, const char **, const char **);
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-tree.h gcc-4.4.7/gcc/c-tree.h
--- gcc-4.4.7.ori/gcc/c-tree.h	2017-02-12 09:19:44.003901290 +0100
+++ gcc-4.4.7/gcc/c-tree.h	2017-02-12 09:19:44.255890823 +0100
@@ -283,10 +283,14 @@
   BOOL_BITFIELD const_p : 1;
   /* Whether "volatile" was specified.  */
   BOOL_BITFIELD volatile_p : 1;
+    int tokid;
+    location_t loc;
+    int typedef_declid;
   /* Whether "restrict" was specified.  */
   BOOL_BITFIELD restrict_p : 1;
   /* Whether "_Sat" was specified.  */
   BOOL_BITFIELD saturating_p : 1;
+
 };
 
 /* The various kinds of declarators in C.  */
@@ -447,6 +451,44 @@
 
 /* in c-aux-info.c */
 extern void gen_aux_info_record (tree, int, int, int);
+extern void gen_aux_info_type (tree);
+
+/* in c-parse-info.c */
+extern location_t gen_parse_info_src2loc (source_location );
+extern void gen_parse_info_header (int, source_location, int *, int);
+extern void gen_parse_info_loc (source_location);
+extern void gen_parse_info_loc_line (source_location);
+extern void gen_parse_info_type (tree);
+extern void gen_parse_info_token (const cpp_token *);
+extern void gen_parse_info_char(const char*);
+extern void gen_parse_info_write(const char*, int);
+extern void gen_parse_info_printf(const char *fmt, ...);
+extern void gen_parse_info_header_direct (int , source_location , int *, int, int );
+extern void gen_parse_info_header_path (int *ar, int arcnt, int, int);
+extern void gen_parse_info_loc_t (location_t loc);
+extern void gen_parse_info_path_direct (int *ar, int arcnt, int dir, int copen, int cclose);
+extern void gen_parse_info_init (struct cpp_parse_info_callbacks *cb);
+extern void gen_parse_info_updateloc (struct cpp_parse_info_callbacks *cb, source_location src_loc, int force);
+
+extern tree gen_parse_info_getrealtype (tree t, int*);
+
+
+/* in c-ppoutput.c */
+struct cppoutput
+{
+  FILE *outf;			/* Stream to write to.  */
+  const cpp_token *prev;	/* Previous token.  */
+  const cpp_token *source;	/* Source token for spacing.  */
+  int src_line;			/* Line number currently being written.  */
+  unsigned char printed;	/* Nonzero if something output at line.  */
+  bool first_time;		/* pp_file_change hasn't been called yet.  */
+};
+extern struct cppoutput cpp_print;
+extern void
+cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,
+	    const unsigned char *dir, const char *header, int angle_brackets,
+	    const cpp_token **comments);
+
 
 /* in c-decl.c */
 extern struct obstack parser_obstack;
@@ -463,7 +505,7 @@
 extern int quals_from_declspecs (const struct c_declspecs *);
 extern struct c_declarator *build_array_declarator (tree, struct c_declspecs *,
 						    bool, bool);
-extern tree build_enumerator (struct c_enum_contents *, tree, tree, location_t);
+extern tree build_enumerator (struct c_enum_contents *, tree, tree, int, location_t);
 extern tree check_for_loop_decls (void);
 extern void mark_forward_parm_decls (void);
 extern void declare_parm_level (void);
@@ -472,9 +514,9 @@
 extern tree define_label (location_t, tree);
 extern void c_maybe_initialize_eh (void);
 extern void finish_decl (tree, tree, tree);
-extern tree finish_enum (tree, tree, tree);
+extern tree finish_enum (tree, tree, tree, int);
 extern void finish_function (void);
-extern tree finish_struct (tree, tree, tree);
+extern tree finish_struct (tree, tree, tree, int);
 extern struct c_arg_info *get_parm_info (bool);
 extern tree grokfield (location_t, struct c_declarator *,
 		       struct c_declspecs *, tree, tree *);
@@ -496,7 +538,7 @@
 extern int  start_function (struct c_declspecs *, struct c_declarator *, tree);
 extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,
 			tree);
-extern tree start_struct (enum tree_code, tree);
+extern tree start_struct (enum tree_code, tree, location_t );
 extern void store_parm_decls (void);
 extern void store_parm_decls_from (struct c_arg_info *);
 extern tree xref_tag (enum tree_code, tree);
@@ -550,9 +592,9 @@
 extern tree c_type_promotes_to (tree);
 extern struct c_expr default_function_array_conversion (struct c_expr);
 extern tree composite_type (tree, tree);
-extern tree build_component_ref (tree, tree);
+extern tree build_component_ref (tree, tree, int);
 extern tree build_array_ref (tree, tree, location_t);
-extern tree build_external_ref (tree, int, location_t);
+extern tree build_external_ref (tree, int, location_t, int );
 extern void pop_maybe_used (bool);
 extern struct c_expr c_expr_sizeof_expr (struct c_expr);
 extern struct c_expr c_expr_sizeof_type (struct c_type_name *);
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/c-typeck.c gcc-4.4.7/gcc/c-typeck.c
--- gcc-4.4.7.ori/gcc/c-typeck.c	2017-02-12 09:19:43.951903450 +0100
+++ gcc-4.4.7/gcc/c-typeck.c	2017-02-12 09:19:44.255890823 +0100
@@ -44,6 +44,7 @@
 #include "tree-iterator.h"
 #include "gimple.h"
 #include "tree-flow.h"
+#include "c-pragma.h"
 
 /* Possible cases of implicit bad conversions.  Used to select
    diagnostic messages in convert_for_assignment.  */
@@ -1906,7 +1907,7 @@
    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */
 
 tree
-build_component_ref (tree datum, tree component)
+build_component_ref (tree datum, tree component, int tokid)
 {
   tree type = TREE_TYPE (datum);
   enum tree_code code = TREE_CODE (type);
@@ -1952,6 +1953,14 @@
 	  quals |= TYPE_QUALS (TREE_TYPE (datum));
 	  subtype = c_build_qualified_type (TREE_TYPE (subdatum), quals);
 
+          if (flag_gen_parse_info && aux_info_file) {
+              tree ty = TREE_TYPE (subdatum);
+              fprintf (aux_info_file, "%d <=[ {ref} (%s) type [",tokid, IDENTIFIER_POINTER (component));
+	      gen_parse_info_type (ty);
+              fprintf (aux_info_file, "] typdecl at: %s:%d\n",TYPE_FILENAME(ty),TYPE_LINENO(ty));
+	      fflush(aux_info_file);
+          }
+	  
 	  ref = build3 (COMPONENT_REF, subtype, datum, subdatum,
 			NULL_TREE);
 	  if (TREE_READONLY (datum) || TREE_READONLY (subdatum))
@@ -2186,7 +2195,7 @@
    whether this will be used for a function call.  LOC is the source
    location of the identifier.  */
 tree
-build_external_ref (tree id, int fun, location_t loc)
+build_external_ref (tree id, int fun, location_t loc, int tokid)
 {
   tree ref;
   tree decl = lookup_name (id);
@@ -2262,6 +2271,31 @@
     pedwarn (loc, 0, "%qD is static but used in inline function %qD "
 	     "which is not static", ref, current_function_decl);
 
+
+  if (flag_gen_parse_info && aux_info_file) {
+      tree ty; const char *refstr = " ref "; int cdeclid = 0;
+      if (TREE_CODE (ref) == FUNCTION_DECL) {
+	  refstr = "(ref)";
+      }
+      if (TREE_CODE (ref) == VAR_DECL ||
+          TREE_CODE (ref) == FUNCTION_DECL ||
+          TREE_CODE (ref) == PARM_DECL) {
+          cdeclid = DECL_DECLID(ref);
+      }
+      fprintf (aux_info_file, "%d(@%d) <=[ %s%s (%s) ",tokid, cdeclid, refstr, DECL_EXTERNAL(ref) ? "^" : " ", IDENTIFIER_POINTER (id));
+      if (decl) {
+          fprintf (aux_info_file, " decl at %s:%d ",LOCATION_FILE(DECL_SOURCE_LOCATION (decl)),LOCATION_LINE(DECL_SOURCE_LOCATION (decl)));
+      }
+      if (decl && (ty = TREE_TYPE (decl))) {
+	  fprintf (aux_info_file, " type [");
+	  gen_parse_info_type (ty);
+	  fprintf (aux_info_file, "] typdecl at: %s:%d \n",TYPE_FILENAME(ty),TYPE_LINENO(ty));
+      } else {
+          fprintf (aux_info_file, " type <unknown> \n");
+      }
+      fflush(aux_info_file);
+  }
+  
   return ref;
 }
 
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/flags.h gcc-4.4.7/gcc/flags.h
--- gcc-4.4.7.ori/gcc/flags.h	2017-02-12 09:19:44.019900625 +0100
+++ gcc-4.4.7/gcc/flags.h	2017-02-12 09:19:44.255890823 +0100
@@ -172,6 +172,12 @@
 
 extern int flag_gen_aux_info;
 
+/* Dump pars info to .X file */
+
+extern int flag_gen_parse_info;
+extern int flag_gen_dep_info;
+extern int flag_gen_parse_id;
+
 /* Nonzero means suppress output of instruction numbers and line number
    notes in debugging dumps.  */
 
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/gcc.c gcc-4.4.7/gcc/gcc.c
--- gcc-4.4.7.ori/gcc/gcc.c	2017-02-12 09:19:43.999901456 +0100
+++ gcc-4.4.7/gcc/gcc.c	2017-02-12 09:19:44.259890657 +0100
@@ -797,8 +797,8 @@
    therefore no dependency entry, confuses make into thinking a .o
    file that happens to exist is up-to-date.  */
 static const char *cpp_unique_options =
-"%{C|CC:%{!E:%eGCC does not support -C or -CC without -E}}\
- %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I\
+"%{C|CC|CCC:%{!E:%eGCC does not support -C, -CC or -CCC without -E}}\
+ %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{CCC} %{v} %{I*&F*} %{P} %I\
  %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\
  %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\
  %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\
@@ -828,6 +828,7 @@
 "%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\
  %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\
  %{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}%{!c:%{!S:-auxbase %b}}\
+ -fparse-info-file=%i.pinfo \
  %{g*} %{O*} %{W*&pedantic*} %{w} %{std*&ansi&trigraphs}\
  %{v:-version} %{pg:-p} %{p} %{f*} %{undef}\
  %{Qn:-fno-ident} %{--help:--help}\
@@ -1109,6 +1110,7 @@
    {"--combine", "-combine", 0},
    {"--comments", "-C", 0},
    {"--comments-in-macros", "-CC", 0},
+   {"--space-as-comments", "-CCC", 0},
    {"--compile", "-c", 0},
    {"--debug", "-g", "oj"},
    {"--define-macro", "-D", "aj"},
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/gcc.pre gcc-4.4.7/gcc/gcc.pre
--- gcc-4.4.7.ori/gcc/gcc.pre	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.7/gcc/gcc.pre	2017-02-12 09:19:44.259890657 +0100
@@ -0,0 +1,175 @@
+#!/bin/bash
+#
+# allow us to do flat processing if the flag -Wl,-elf2flt or -elf2flt to
+# the 'C' compiler or linker respectively
+#
+# uses the env. var FLTFLAGS as extra parameters to pass to elf2flt
+# arguments given like -Wl,-elf2flt="-b 10000 -v" are given before FLTFLAGS
+#
+# Copyright (C) 2002,2003 David McCullough <davidm@snapgear.com>
+# Copyright (C) 2000, Lineo. davidm@lineo.com
+#
+# This is Free Software, under the GNU Public Licence v2 or greater.
+#
+
+LINKER="$0.real"            # the original renamed-linker
+ELF2FLT="`expr $0 : '\(.*\)ld'`elf2flt"
+TOOLDIR="`dirname $0`"      # let gcc find the tools for us
+LDSCRIPTPATH="${TOOLDIR}/../sparc-linux/lib"		# and the scripts
+SHARED_ID=""
+NEWLDSCRIPT=""
+
+# check TOOLDIR from prefix/bin/ or prefix/target-alias/bin/
+[ -d "${TOOLDIR}/../sparc-linux/lib" ] || LDSCRIPTPATH="${TOOLDIR}/../lib"
+
+#
+# if we have the elf2flt options, run it
+#
+
+if expr "$*" : ".*-elf2flt.*" > /dev/null
+then
+	ARG1=
+	ARG2=
+	OFILE="a.out"
+	PIC=
+	SDIRS=
+	LDSCRIPT=
+	FINAL="yes"
+	FINAL_ONLY=
+	MOVDAT=
+	VERBOSE=
+
+	while [ $# -ne 0 ]
+	do
+		case "$1" in
+
+		-elf2flt) ;;                           # we already know this
+		-elf2flt*)FLTFLAGS="`expr \"$1\" : '-elf2flt=\(.*\)'` $FLTFLAGS";; 
+
+		-move-rodata)
+		          MOVDAT="y";;                 # Put rodata in ROM if possible
+			 
+		-shared-lib-id)
+		          shift; SHARED_ID="$1";;      # Shared library ID
+
+		-o)       shift; OFILE="$1";;          # the final outfile
+		-o*)      OFILE="`expr \"$1\" : '-o\(.*\)'`";;
+
+		-T)       shift; LDSCRIPT="$1";;       # they have a linker script
+		-c)       shift; LDSCRIPT="$1";;
+
+		-L)       ARG1="$ARG1 $1"              # remember search dirs
+		          shift;
+				  ARG1="$ARG1 $1"
+				  SDIRS="$SDIRS -L$1"
+				  ;;
+		-L*)      ARG1="$ARG1 $1"; SDIRS="$SDIRS $1";;
+
+		-EB)      ARG1="$ARG1 $1"; SDIRS="$SDIRS $1";; # arm big endian
+
+		-relax)   ;;                           # eat this for microblaze
+
+		-r|-Ur)   FINAL=""                     # this is not a final link
+		          ARG1="$ARG1 $1"
+				  ;;
+
+		-v)       ARG1="$ARG1 $1"
+				  VERBOSE="y"
+				  ;;
+
+		-m)       shift; EMUL="-m $1";;        # ld emulations for h8300
+		-m*)      EMUL=$1;;
+ 
+		*)        ARG1="$ARG1 $1"
+				  ;;
+		esac
+		shift
+	done
+
+	if [ "$FINAL" = "yes" ]
+	then
+		[ "$VERBOSE" = "y" ] && set -x
+		ARG1="$ARG1 $FINAL_ONLY"
+		NEWLDSCRIPT=`mktemp /tmp/flt-XXXXXX`
+		SEDOP=" -e s/^R_RODAT// -e /^W_RODAT/d"
+		if [ "$MOVDAT" ]
+		then
+			$LINKER -r -d -o "$OFILE.elf2flt" $ARG1  || exit $?
+			if [ "`sparc-linux-objdump -h "$OFILE.elf2flt" | \
+					egrep -A1 '[.]rodata' | grep RELOC`" ]
+			then
+				echo "warning: .rodata section contains relocations"
+			else
+				SEDOP="-e /^R_RODAT/d -e s/^W_RODAT//"
+			fi
+		fi
+		if [ "$SHARED_ID" ]
+		then
+			# Massage the linker script into something useful.  These
+			# regexps are ugly due to some bizzare shell quoting rules.
+			#    SEDOP="$SEDOP -e \"s/ORIGIN = 0x0,/ORIGIN = 0x${SHARED_ID}000000,/\""
+			#    SEDOP="$SEDOP -e \"s/.text 0x0 :/.text 0x${SHARED_ID}000000 :/\""			
+			SEDOP="$SEDOP -e s/\\(ORIGIN.=.0\\)x0,/\\1x${SHARED_ID}000000,/"
+			SEDOP="$SEDOP -e s/\\([.]text.0\\)x0[^0-9]:/\\1x${SHARED_ID}000000:/"
+			
+			if [ "$SHARED_ID" -gt 0 ]
+			then
+				# Non application modules enter via main not _start
+				#    SEDOP="$SEDOP -e 's/ENTRY (_start)/ENTRY (main)/'"
+				SEDOP="$SEDOP -e s/\\(ENTRY.\\)(_start)/\1(lib_main)/"
+			fi
+
+			# Provide the magic parameter that defines the library data segment pointer offset
+			case "sparc" in
+			    h8300) GOT_OFFSET="__current_shared_library_er5_offset_";;
+			    *)     GOT_OFFSET="_current_shared_library_a5_offset_";;
+			esac
+			ARG1="$ARG1 -defsym $GOT_OFFSET=`expr ${SHARED_ID} '*' -4 - 4`"
+		fi
+		
+		# provide a default linker script, we usually need one
+		[ -z "$LDSCRIPT" ] && LDSCRIPT="${LDSCRIPTPATH}/elf2flt.ld"
+
+		# if we can find the linker script we preprocess it,  otherwise
+		# we assume the user knows what they are doing
+		if [ -f "$LDSCRIPT" ]; then
+			sed $SEDOP < "$LDSCRIPT" > "$NEWLDSCRIPT"
+			LDSCRIPT="$NEWLDSCRIPT"
+		elif [ -f "${LDSCRIPTPATH}/$LDSCRIPT" ]; then
+			sed $SEDOP < "${LDSCRIPTPATH}/$LDSCRIPT" > "$NEWLDSCRIPT"
+			LDSCRIPT="$NEWLDSCRIPT"
+		elif [ -f "${LDSCRIPTPATH}/ldscripts/$LDSCRIPT" ]; then
+			sed $SEDOP < "${LDSCRIPTPATH}/ldscripts/$LDSCRIPT" > "$NEWLDSCRIPT"
+			LDSCRIPT="$NEWLDSCRIPT"
+		fi
+
+		if [ "yes" = "no" ]
+		then
+		 $LINKER $EMUL $SDIRS -T $LDSCRIPT -Ur -d -o "$OFILE.elf" $ARG1         ||exit $?
+		 $LINKER $EMUL $SDIRS -T $LDSCRIPT -o "$OFILE.gdb" $ARG1                ||exit $?
+		else
+		 $LINKER $EMUL -r -d -o "$OFILE.elf2flt" $ARG1                          ||exit $?
+		 $LINKER $EMUL $SDIRS -T $LDSCRIPT -Ur -o "$OFILE.elf" "$OFILE.elf2flt" ||exit $?
+		 $LINKER $EMUL $SDIRS -T $LDSCRIPT -o "$OFILE.gdb" "$OFILE.elf2flt"     ||exit $?
+		 rm -f "$OFILE.elf2flt"
+		fi
+		if grep _GLOBAL_OFFSET_TABLE_ "$OFILE.gdb" > /dev/null 
+		then
+			$ELF2FLT $FLTFLAGS -o "$OFILE" -p "$OFILE.gdb" "$OFILE.elf" || exit $?
+		else
+			$ELF2FLT $FLTFLAGS -o "$OFILE" -r "$OFILE.elf" || exit $?
+		fi
+		rm -f "$OFILE.elf"  # not needed for any reason
+		rm -f "$NEWLDSCRIPT"
+		exit 0
+	fi
+
+	exec $LINKER -o "$OFILE" $ARG1
+fi
+
+#
+# otherwise pretend we aren't here
+#
+
+exec $LINKER "$@"
+
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/gcc.pre.sh gcc-4.4.7/gcc/gcc.pre.sh
--- gcc-4.4.7.ori/gcc/gcc.pre.sh	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.7/gcc/gcc.pre.sh	2017-02-12 09:19:44.259890657 +0100
@@ -0,0 +1,50 @@
+#!/bin/bash
+
+ARG1=
+GCCREAL="$0.real"            # the original renamed-linker
+PISUFFIX=".pinfo"
+PIFILE=""
+PIFILEOPT=""
+PINO=0
+VERBOSE=0
+PILOCK1=0
+PILOCK2=0
+
+while [ $# -ne 0 ]
+do
+    case "$1" in
+        -fno-parse-info) PINO=1;;
+        -fparse-info-file=*) if [ $PILOCK1 == 0 ]; then PIFILE=`expr "$1" : '-fparse-info-file=\(.*\)'`; PILOCK2=1; fi;; 
+        -fparse-info=*) PIFILE=`expr "$1" : '-fparse-info=\(.*\)'`; PILOCK1=1;;
+        -dumpbase) shift; if [ $PILOCK1 == 0 -a $PILOCK2 == 0 ]; then PIFILE="$1$PISUFFIX"; fi;;
+        -verbose) VERBOSE=1;;
+	*)         ARG1="$ARG1 $1";;
+    esac
+    shift
+done
+
+if [ $PINO == 1 ]; then PIFILE=; fi
+if [ "x$PIFILE" != "x" ]; then PIFILEOPT="-fparse-info=$PIFILE"; fi
+$GCCREAL $ARG1 $PIFILEOPT -fparse-id=1
+
+QUITE=
+if [ "x`expr "${M_QUITE}" : '\(y\)'`" == "xy" ]
+then
+QUITE=" --quite"
+fi
+
+if [ "x$PIFILE" != "x" ]
+then
+    if which htmltag.pl &> /dev/null 
+    then
+        if [ "x`expr "${M_QUITE}" : '\(y\)'`" != "xy" ]
+        then
+        #if [ $VERBOSE == 1 ]
+        #then
+            echo htmltag.pl $PIFILE $CONFIG_HTMLTAG_STYLE $QUITE -o $PIFILE.html 
+        #fi
+	fi
+        htmltag.pl $PIFILE $CONFIG_HTMLTAG_STYLE $QUITE -o $PIFILE.html 
+    fi
+fi
+
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/genmodes.c gcc-4.4.7/gcc/genmodes.c
--- gcc-4.4.7.ori/gcc/genmodes.c	2017-02-12 09:19:44.055899130 +0100
+++ gcc-4.4.7/gcc/genmodes.c	2017-02-12 09:19:44.259890657 +0100
@@ -837,7 +837,7 @@
 
 #define tagged_printf(FMT, ARG, TAG) do {		\
   int count_ = printf ("  " FMT ",", ARG);		\
-  printf ("%*s/* %s */\n", 27 - count_, "", TAG);	\
+  printf ("\t/* %s [%d], */\n", TAG, count_); \
 } while (0)
 
 #define print_decl(TYPE, NAME, ASIZE) \
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/gimplify.c gcc-4.4.7/gcc/gimplify.c
--- gcc-4.4.7.ori/gcc/gimplify.c	2017-02-12 09:19:44.023900459 +0100
+++ gcc-4.4.7/gcc/gimplify.c	2017-02-12 09:19:44.259890657 +0100
@@ -52,7 +52,7 @@
 #include "splay-tree.h"
 #include "vec.h"
 #include "gimple.h"
-
+#include "c-tree.h"
 
 enum gimplify_omp_var_data
 {
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/input.h gcc-4.4.7/gcc/input.h
--- gcc-4.4.7.ori/gcc/input.h	2017-02-12 09:19:44.015900792 +0100
+++ gcc-4.4.7/gcc/input.h	2017-02-12 09:19:44.259890657 +0100
@@ -56,6 +56,7 @@
 extern const char *main_input_filename;
 
 extern location_t input_location;
+extern source_location input_source_location;
 
 #define LOCATION_FILE(LOC) ((expand_location (LOC)).file)
 #define LOCATION_LINE(LOC) ((expand_location (LOC)).line)
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/Makefile.in gcc-4.4.7/gcc/Makefile.in
--- gcc-4.4.7.ori/gcc/Makefile.in	2017-02-12 09:19:44.015900792 +0100
+++ gcc-4.4.7/gcc/Makefile.in	2017-02-12 09:19:44.263890492 +0100
@@ -682,6 +682,12 @@
 # A list of all the language-specific executables.
 COMPILERS = cc1$(exeext) @all_compilers@
 
+PINFOCOMPILERS      = cc1$(exeext)
+PINFOCOMPILERSREAL  = cc1.real$(exeext)
+PINFOCOMPILERSPP      = cc1plus$(exeext)
+PINFOCOMPILERSREALPP  = cc1plus.real$(exeext)
+PINFOCOMPILERSREDIR = $(srcdir)/gcc.pre.sh
+
 # List of things which should already be built whenever we try to use xgcc
 # to compile anything (without linking).
 GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES)
@@ -1026,7 +1032,7 @@
 
 # Language-specific object files for C and Objective C.
 C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \
-  c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
+  c-convert.o c-aux-info.o c-parse-info.o c-common.o c-opts.o c-format.o c-semantics.o \
   c-ppoutput.o c-cppbuiltin.o \
   c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \
   c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o
@@ -1848,6 +1854,8 @@
     tree-mudflap.h
 c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(C_TREE_H) $(FLAGS_H) $(TOPLEV_H)
+c-parse-info.o : c-parse-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(FLAGS_H) toplev.h
 c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
     $(TREE_H) $(FLAGS_H) $(TOPLEV_H) $(C_COMMON_H) convert.h $(C_TREE_H) \
     langhooks.h $(TARGET_H)
@@ -4099,7 +4107,7 @@
 # Install the driver last so that the window when things are
 # broken is small.
 install: install-common $(INSTALL_HEADERS) \
-    install-cpp install-man install-info install-@POSUB@ \
+    install-cpp \
     install-driver
 
 # Handle cpp installation.
@@ -4128,7 +4136,15 @@
 	for file in $(COMPILERS); do \
 	  if [ -f $$file ] ; then \
 	    rm -f $(DESTDIR)$(libexecsubdir)/$$file; \
+	    if [ "$$file" = "$(PINFOCOMPILERS)" ] ; then \
+		$(INSTALL_PROGRAM) $$file                 $(DESTDIR)$(libexecsubdir)/$(PINFOCOMPILERSREAL); \
+		$(INSTALL_PROGRAM) $(PINFOCOMPILERSREDIR) $(DESTDIR)$(libexecsubdir)/$$file; \
+            elif [ "$$file" = "$(PINFOCOMPILERSPP)" ] ; then \
+		$(INSTALL_PROGRAM) $$file                 $(DESTDIR)$(libexecsubdir)/$(PINFOCOMPILERSREALPP); \
+		$(INSTALL_PROGRAM) $(PINFOCOMPILERSREDIR) $(DESTDIR)$(libexecsubdir)/$$file; \
+            else \
 	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libexecsubdir)/$$file; \
+	    fi; \
 	  else true; \
 	  fi; \
 	done
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/opts.c gcc-4.4.7/gcc/opts.c
--- gcc-4.4.7.ori/gcc/opts.c	2017-02-12 09:19:44.007901124 +0100
+++ gcc-4.4.7/gcc/opts.c	2017-02-12 09:19:44.263890492 +0100
@@ -1644,12 +1644,47 @@
       warn_unused = value;
       break;
 
+    case OPT_fhtmltag_fid_:
+    case OPT_fhtmltag_linkid_:
+     break;      
+      
     case OPT_aux_info:
     case OPT_aux_info_:
       aux_info_file_name = arg;
       flag_gen_aux_info = 1;
       break;
 
+    case OPT_ftrace_funcs:
+    case OPT_ftrace_funcs_:
+      trace_funcs_file_name = arg;
+      flag_gen_trace_funcs = 1;
+      break;
+
+    case OPT_ftrace_type:
+    case OPT_ftrace_type_:
+	    if (strncmp(arg,"trace_out_none",strlen("trace_out_none")) == 0)
+		    tracetype = trace_out_none;
+	    else if (strncmp(arg,"trace_out_all",strlen("trace_out_all")) == 0)
+		    tracetype = trace_out_all;
+	    else
+		    printf(stderr,"Unknown trace type %s\n",arg);
+      break;
+      
+    case OPT_fparse_info:
+    case OPT_fparse_info_:
+      aux_info_file_name = arg;
+      flag_gen_parse_info = 1;
+      break;
+
+    case OPT_fparse_info_file:
+    case OPT_fparse_info_file_:
+      parse_info_file_name = arg;
+      break;
+      
+    case OPT_fparse_id_:
+      flag_gen_parse_id = value;
+      break;
+      
     case OPT_auxbase:
       aux_base_name = arg;
       break;
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/toplev.c gcc-4.4.7/gcc/toplev.c
--- gcc-4.4.7.ori/gcc/toplev.c	2017-02-12 09:19:44.015900792 +0100
+++ gcc-4.4.7/gcc/toplev.c	2017-02-12 09:20:11.342765750 +0100
@@ -84,6 +84,7 @@
 #include "tree-mudflap.h"
 #include "tree-pass.h"
 #include "gimple.h"
+#include "c-tree.h"
 
 #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)
 #include "dwarf2out.h"
@@ -103,8 +104,8 @@
 #endif
 
 static void general_init (const char *);
-static void do_compile (void);
-static void process_options (void);
+static void do_compile (unsigned int argc, const char **argv);
+static void process_options (unsigned int argc, const char **argv);
 static void backend_init (void);
 static int lang_dependent_init (const char *);
 static void init_asm_output (const char *);
@@ -143,6 +144,7 @@
 /* Current position in real source file.  */
 
 location_t input_location;
+source_location input_source_location;
 
 struct line_maps *line_table;
 
@@ -250,9 +252,19 @@
 
 int flag_gen_aux_info = 0;
 
+/* Dump pars info to .X file */
+		      
+int flag_gen_parse_info = 0;
+int flag_gen_dep_info = 0;
+int flag_gen_parse_id = -1;
+
 /* Specified name of aux-info file.  */
 
 const char *aux_info_file_name;
+const char *parse_info_file_name;
+char *trace_funcs_file_name = 0;
+int flag_gen_trace_funcs = 0;
+enum trace_types tracetype = trace_out_all;
 
 /* Nonzero if we are compiling code for a shared library, zero for
    executable.  */
@@ -527,7 +539,7 @@
    for floor_log2 and exact_log2; see toplev.h.  That construct, however,
    conflicts with the ISO C++ One Definition Rule.   */
 
-#if GCC_VERSION < 3004 || !defined (__cplusplus)
+#if GCC_VERSION < 3004
 
 /* Given X, an unsigned number, return the largest int Y such that 2**Y <= X.
    If X is 0, return -1.  */
@@ -991,6 +1003,8 @@
      functions in this compilation unit were deferred.  */
   coverage_finish ();
 
+  /*gimplify_finish ();*/
+  
   /* Likewise for mudflap static object registrations.  */
   if (flag_mudflap)
     mudflap_finish_file ();
@@ -1655,8 +1669,8 @@
 }
 
 /* Process the options that have been parsed.  */
-static void
-process_options (void)
+void 
+process_options (unsigned int argc, const char **argv)
 {
   /* Just in case lang_hooks.post_options ends up calling a debug_hook.
      This can happen with incorrect pre-processed input. */
@@ -1881,9 +1895,22 @@
   /* If auxiliary info generation is desired, open the output file.
      This goes in the same directory as the source file--unlike
      all the other output files.  */
-  if (flag_gen_aux_info)
+  if (flag_gen_aux_info || flag_gen_parse_info)
     {
       aux_info_file = fopen (aux_info_file_name, "w");
+      if (flag_gen_parse_info) {
+  	  unsigned int i = 0;
+          cpp_print.outf = aux_info_file;
+	  gen_parse_info_printf("call (%s):[",progname);
+	  for (i = 0; i < argc; i++) {
+	    gen_parse_info_printf(" %s",argv[i]);
+	  }
+	  gen_parse_info_printf("]");
+	  if (flag_gen_parse_id != -1) {
+	    gen_parse_info_printf("=%d",flag_gen_parse_id);
+	  }
+	  gen_parse_info_printf("\n");
+      }
       if (aux_info_file == 0)
 	fatal_error ("can%'t open %s: %m", aux_info_file_name);
     }
@@ -2137,7 +2164,7 @@
 finalize (void)
 {
   /* Close the dump files.  */
-  if (flag_gen_aux_info)
+  if (flag_gen_aux_info || flag_gen_parse_info)
     {
       fclose (aux_info_file);
       if (errorcount)
@@ -2170,7 +2197,7 @@
 
 /* Initialize the compiler, and compile the input file.  */
 static void
-do_compile (void)
+do_compile (unsigned int argc, const char **argv)
 {
   /* Initialize timing first.  The C front ends read the main file in
      the post_options hook, and C++ does file timings.  */
@@ -2178,7 +2205,7 @@
     timevar_init ();
   timevar_start (TV_TOTAL);
 
-  process_options ();
+  process_options (argc,argv);
 
   /* Don't do any more if an error has already occurred.  */
   if (!errorcount)
@@ -2226,7 +2253,7 @@
 
   /* Exit early if we can (e.g. -help).  */
   if (!exit_after_options)
-    do_compile ();
+    do_compile (argc, argv);
 
   if (warningcount || errorcount) 
     print_ignored_options ();
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/toplev.h gcc-4.4.7/gcc/toplev.h
--- gcc-4.4.7.ori/gcc/toplev.h	2017-02-12 09:19:44.019900625 +0100
+++ gcc-4.4.7/gcc/toplev.h	2017-02-12 09:19:57.799328287 +0100
@@ -117,10 +117,22 @@
 extern const char *dump_base_name;
 extern const char *aux_base_name;
 extern const char *aux_info_file_name;
+extern const char *parse_info_file_name;
 extern const char *profile_data_prefix;
 extern const char *asm_file_name;
 extern bool exit_after_options;
 
+extern FILE *aux_info_file;
+extern char *trace_funcs_file_name;
+extern int flag_gen_trace_funcs;
+
+enum trace_types {
+	trace_out_none,
+	trace_out_all
+};
+extern enum trace_types tracetype;
+
+
 /* True if the user has tagged the function with the 'section'
    attribute.  */
 
@@ -186,13 +198,13 @@
 #  define CTZ_HWI __builtin_ctz
 # endif
 
-extern inline int
+static inline int
 floor_log2 (unsigned HOST_WIDE_INT x)
 {
   return x ? HOST_BITS_PER_WIDE_INT - 1 - (int) CLZ_HWI (x) : -1;
 }
 
-extern inline int
+static inline int
 exact_log2 (unsigned HOST_WIDE_INT x)
 {
   return x == (x & -x) && x ? (int) CTZ_HWI (x) : -1;
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/tree.c gcc-4.4.7/gcc/tree.c
--- gcc-4.4.7.ori/gcc/tree.c	2017-02-12 09:19:44.019900625 +0100
+++ gcc-4.4.7/gcc/tree.c	2017-02-12 09:19:44.263890492 +0100
@@ -694,6 +694,8 @@
 
       /* We have not yet computed the alias set for this type.  */
       TYPE_ALIAS_SET (t) = -1;
+      
+      TYPE_LOCATION (t)     = input_location;
       break;
 
     case tcc_constant:
diff -Naurb '--exclude=*.v87' '--exclude=*.v93' gcc-4.4.7.ori/gcc/tree.h gcc-4.4.7/gcc/tree.h
--- gcc-4.4.7.ori/gcc/tree.h	2017-02-12 09:19:44.015900792 +0100
+++ gcc-4.4.7/gcc/tree.h	2017-02-12 09:19:44.267890325 +0100
@@ -373,6 +373,8 @@
   unsigned saturating_flag : 1;
   unsigned default_def_flag : 1;
 
+  location_t locus;
+  
   unsigned lang_flag_0 : 1;
   unsigned lang_flag_1 : 1;
   unsigned lang_flag_2 : 1;
@@ -2254,6 +2256,22 @@
 #define TYPE_CONTAINS_PLACEHOLDER_INTERNAL(NODE) \
   (TYPE_CHECK (NODE)->type.contains_placeholder_bits)
 
+#define TYPE_LOCATION(NODE)					\
+  (NODE)->type.locus
+
+#define TYPE_STRUCTID(NODE) \
+  (TYPE_CHECK (NODE)->type.structid)
+#define TYPE_DEP(NODE) \
+  (TYPE_CHECK (NODE)->type.dep)
+
+#define TYPE_FILENAME(NODE) \
+  (LOCATION_FILE(TYPE_CHECK (NODE)->type.locus)/*.file*/)
+#define TYPE_LINENO(NODE) \
+  (LOCATION_LINE(TYPE_CHECK (NODE)->type.locus)/*.line*/)
+#define TYPE_LOCUS(NODE)					\
+  (TYPE_P (NODE) ? (NODE)->type.locus : (location_t *)NULL)
+#define TYPE_HAS_LOCATION(NODE) (TYPE_LOCUS (NODE) != NULL)
+
 struct die_struct;
 
 struct tree_type GTY(())
@@ -2276,6 +2294,8 @@
   unsigned restrict_flag : 1;
   unsigned contains_placeholder_bits : 2;
 
+  location_t locus;
+  
   unsigned lang_flag_0 : 1;
   unsigned lang_flag_1 : 1;
   unsigned lang_flag_2 : 1;
@@ -2305,6 +2325,9 @@
   tree canonical;
   /* Points to a structure whose details depend on the language in use.  */
   struct lang_type *lang_specific;
+  int structid;
+  struct dep_decl * GTY((skip)) dep; 
+
 };
 
 /* Define accessor macros for information about type inheritance
@@ -2472,6 +2495,8 @@
    function that is declared first and then defined later), this
    information should refer to the definition.  */
 #define DECL_SOURCE_LOCATION(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.locus)
+#define DECL_DEP(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.dep)
+#define DECL_DECLID(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.declid)
 #define DECL_SOURCE_FILE(NODE) LOCATION_FILE (DECL_SOURCE_LOCATION (NODE))
 #define DECL_SOURCE_LINE(NODE) LOCATION_LINE (DECL_SOURCE_LOCATION (NODE))
 #define DECL_IS_BUILTIN(DECL) \
@@ -2490,11 +2515,34 @@
 {
   struct tree_common common;
   location_t locus;
+  struct dep_decl * GTY((skip)) dep; 
   unsigned int uid;
   tree name;
   tree context;
+  int declid;
 };
 
+struct dep_decl {
+	int depid;
+	tree decl;
+	int dep_cnt;
+	int mdep_cnt;
+	struct dep_decl **dep;
+	struct cpp_macro **mdep;
+	location_t start, end;
+};
+extern struct dep_decl main_dep;
+extern struct dep_decl real_dep;
+void dep_add(struct dep_decl *d0, struct dep_decl *d1);
+void mdep_add(struct dep_decl *d0, struct cpp_macro *m);
+struct dep_decl *dep_open(void);
+struct dep_decl *dep_close(struct dep_decl *d, tree decl);
+void gen_dep_info_macro(struct cpp_macro *);
+void dep_pop(struct dep_decl *d0);
+void dep_add_top(struct dep_decl *d);
+void mdep_add_top(struct cpp_macro *m);
+
+
 /* When computing aliasing information, we represent the memory pointed-to
    by pointers with artificial variables called "memory tags" (MT).  There
    are two kinds of tags, namely symbol and name:
@@ -2854,6 +2902,8 @@
 #define DECL_NONADDRESSABLE_P(NODE) \
   (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_3)
 
+#define FIELD_DECL_TOKID(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.tokid)
+
 struct tree_field_decl GTY(())
 {
   struct tree_decl_common common;
@@ -2864,6 +2914,7 @@
   tree bit_offset;
   tree fcontext;
 
+  int tokid;
 };
 
 /* A numeric unique identifier for a LABEL_DECL.  The UID allocation is
@@ -2886,9 +2937,13 @@
   struct tree_decl_with_rtl common;
 };
 
+#define CONST_DECL_TOKID(NODE) ((NODE)->const_decl.tokid)
+
 struct tree_const_decl GTY(())
 {
   struct tree_decl_with_rtl common;
+  int tokid;
+
 };
 
 /* For a PARM_DECL, records the data type used to pass the argument,
